diff --git a/Include/pythonrun.h b/Include/pythonrun.h
index 6f0c6fc..0a17edd 100644
--- a/Include/pythonrun.h
+++ b/Include/pythonrun.h
@@ -7,6 +7,8 @@
 extern "C" {
 #endif
 
+PyAPI_FUNC(const char *) Py_GetLib(void);
+
 #ifndef Py_LIMITED_API
 PyAPI_FUNC(int) PyRun_SimpleStringFlags(const char *, PyCompilerFlags *);
 PyAPI_FUNC(int) PyRun_AnyFileFlags(FILE *, const char *, PyCompilerFlags *);
diff --git a/Lib/site.py b/Lib/site.py
index 4829f88..2f7f802 100644
--- a/Lib/site.py
+++ b/Lib/site.py
@@ -341,7 +341,7 @@ def getsitepackages(prefixes=None):
 
         if os.sep == '/':
             if 'VIRTUAL_ENV' in os.environ or sys.base_prefix != sys.prefix:
-                sitepackages.append(os.path.join(prefix, "lib",
+                sitepackages.append(os.path.join(prefix, sys.lib,
                                                  "python" + sys.version[:3],
                                                  "site-packages"))
             sitepackages.append(os.path.join(prefix, "local/lib",
@@ -356,7 +356,7 @@ def getsitepackages(prefixes=None):
                                              "dist-packages"))
         else:
             sitepackages.append(prefix)
-            sitepackages.append(os.path.join(prefix, "lib", "site-packages"))
+            sitepackages.append(os.path.join(prefix, sys.lib, "site-packages"))
     return sitepackages
 
 def addsitepackages(known_paths, prefixes=None):
diff --git a/Makefile.pre.in b/Makefile.pre.in
index c5fc565..6cdf5c6 100644
--- a/Makefile.pre.in
+++ b/Makefile.pre.in
@@ -136,7 +136,7 @@ LIBDIR=		@libdir@
 MANDIR=		@mandir@
 INCLUDEDIR=	@includedir@
 CONFINCLUDEDIR=	$(exec_prefix)/include
-SCRIPTDIR=	$(prefix)/lib
+SCRIPTDIR=	@libdir@
 ABIFLAGS=	@ABIFLAGS@
 
 # Detailed destination directories
@@ -776,6 +776,7 @@ Modules/getpath.o: $(srcdir)/Modules/getpath.c Makefile
 		-DEXEC_PREFIX='"$(exec_prefix)"' \
 		-DVERSION='"$(VERSION)"' \
 		-DVPATH='"$(VPATH)"' \
+		-DLIB='"$(LIB)"' \
 		-o $@ $(srcdir)/Modules/getpath.c
 
 Programs/python.o: $(srcdir)/Programs/python.c
@@ -865,7 +866,7 @@ regen-opcode:
 Python/compile.o Python/symtable.o Python/ast_unparse.o Python/ast.o: $(srcdir)/Include/graminit.h $(srcdir)/Include/Python-ast.h
 
 Python/getplatform.o: $(srcdir)/Python/getplatform.c
-		$(CC) -c $(PY_CORE_CFLAGS) -DPLATFORM='"$(MACHDEP)"' -o $@ $(srcdir)/Python/getplatform.c
+		$(CC) -c $(PY_CORE_CFLAGS) -DPLATFORM='"$(MACHDEP)"' -DLIB='"$(LIB)"' -o $@ $(srcdir)/Python/getplatform.c
 
 Python/importdl.o: $(srcdir)/Python/importdl.c
 		$(CC) -c $(PY_CORE_CFLAGS) -I$(DLINCLDIR) -o $@ $(srcdir)/Python/importdl.c
diff --git a/Makefile.pre.in.orig b/Makefile.pre.in.orig
new file mode 100644
index 0000000..c5fc565
--- /dev/null
+++ b/Makefile.pre.in.orig
@@ -0,0 +1,1803 @@
+# Top-level Makefile for Python
+#
+# As distributed, this file is called Makefile.pre.in; it is processed
+# into the real Makefile by running the script ./configure, which
+# replaces things like @spam@ with values appropriate for your system.
+# This means that if you edit Makefile, your changes get lost the next
+# time you run the configure script.  Ideally, you can do:
+#
+#	./configure
+#	make
+#	make test
+#	make install
+#
+# If you have a previous version of Python installed that you don't
+# want to overwrite, you can use "make altinstall" instead of "make
+# install".  Refer to the "Installing" section in the README file for
+# additional details.
+#
+# See also the section "Build instructions" in the README file.
+
+# === Variables set by makesetup ===
+
+MODBUILT_NAMES=    _MODBUILT_NAMES_
+MODDISABLED_NAMES= _MODDISABLED_NAMES_
+# filter out duplicate object files (_math.o)
+MODOBJS=           $(sort _MODOBJS_)
+MODLIBS=           _MODLIBS_
+
+# === Variables set by configure
+VERSION=	@VERSION@
+srcdir=		@srcdir@
+VPATH=		@srcdir@
+abs_srcdir=	@abs_srcdir@
+abs_builddir=	@abs_builddir@
+
+
+CC=		@CC@
+CXX=		@CXX@
+MAINCC=		@MAINCC@
+LINKCC=		@LINKCC@
+AR=		@AR@
+READELF=	@READELF@
+SOABI=		@SOABI@
+LDVERSION=	@LDVERSION@
+GITVERSION=	@GITVERSION@
+GITTAG=		@GITTAG@
+GITBRANCH=	@GITBRANCH@
+PGO_PROF_GEN_FLAG=@PGO_PROF_GEN_FLAG@
+PGO_PROF_USE_FLAG=@PGO_PROF_USE_FLAG@
+LLVM_PROF_MERGER=@LLVM_PROF_MERGER@
+LLVM_PROF_FILE=@LLVM_PROF_FILE@
+LLVM_PROF_ERR=@LLVM_PROF_ERR@
+DTRACE=         @DTRACE@
+DFLAGS=         @DFLAGS@
+DTRACE_HEADERS= @DTRACE_HEADERS@
+DTRACE_OBJS=    @DTRACE_OBJS@
+
+GNULD=		@GNULD@
+
+# Shell used by make (some versions default to the login shell, which is bad)
+SHELL=		/bin/sh
+
+# Use this to make a link between python$(VERSION) and python in $(BINDIR)
+LN=		@LN@
+
+# Portable install script (configure doesn't always guess right)
+INSTALL=	@INSTALL@
+INSTALL_PROGRAM=@INSTALL_PROGRAM@
+INSTALL_SCRIPT= @INSTALL_SCRIPT@
+INSTALL_DATA=	@INSTALL_DATA@
+# Shared libraries must be installed with executable mode on some systems;
+# rather than figuring out exactly which, we always give them executable mode.
+# Also, making them read-only seems to be a good idea...
+INSTALL_SHARED= ${INSTALL} -m 555
+
+MKDIR_P=	@MKDIR_P@
+
+MAKESETUP=      $(srcdir)/Modules/makesetup
+
+# Compiler options
+OPT=		@OPT@
+BASECFLAGS=	@BASECFLAGS@
+BASECPPFLAGS=	@BASECPPFLAGS@
+CONFIGURE_CFLAGS=	@CFLAGS@
+# CFLAGS_NODIST is used for building the interpreter and stdlib C extensions.
+# Use it when a compiler flag should _not_ be part of the distutils CFLAGS
+# once Python is installed (Issue #21121).
+CONFIGURE_CFLAGS_NODIST=@CFLAGS_NODIST@
+CONFIGURE_CPPFLAGS=	@CPPFLAGS@
+CONFIGURE_LDFLAGS=	@LDFLAGS@
+# Avoid assigning CFLAGS, LDFLAGS, etc. so users can use them on the
+# command line to append to these values without stomping the pre-set
+# values.
+PY_CFLAGS=	$(BASECFLAGS) $(OPT) $(CONFIGURE_CFLAGS) $(CFLAGS) $(EXTRA_CFLAGS)
+PY_CFLAGS_NODIST=$(CONFIGURE_CFLAGS_NODIST) $(CFLAGS_NODIST)
+# Both CPPFLAGS and LDFLAGS need to contain the shell's value for setup.py to
+# be able to build extension modules using the directories specified in the
+# environment variables
+PY_CPPFLAGS=	$(BASECPPFLAGS) -I. -I$(srcdir)/Include $(CONFIGURE_CPPFLAGS) $(CPPFLAGS)
+PY_LDFLAGS=	$(CONFIGURE_LDFLAGS) $(LDFLAGS)
+NO_AS_NEEDED=	@NO_AS_NEEDED@
+LDLAST=		@LDLAST@
+SGI_ABI=	@SGI_ABI@
+CCSHARED=	@CCSHARED@
+LINKFORSHARED=	@LINKFORSHARED@
+ARFLAGS=	@ARFLAGS@
+# Extra C flags added for building the interpreter object files.
+CFLAGSFORSHARED=@CFLAGSFORSHARED@
+# C flags used for building the interpreter object files
+PY_STDMODULE_CFLAGS= $(PY_CFLAGS) $(PY_CFLAGS_NODIST) $(PY_CPPFLAGS) $(CFLAGSFORSHARED)
+PY_BUILTIN_MODULE_CFLAGS= $(PY_STDMODULE_CFLAGS) -DPy_BUILD_CORE_BUILTIN
+PY_CORE_CFLAGS=	$(PY_STDMODULE_CFLAGS) -DPy_BUILD_CORE
+# Strict or non-strict aliasing flags used to compile dtoa.c, see above
+CFLAGS_ALIASING=@CFLAGS_ALIASING@
+
+
+# Machine-dependent subdirectories
+MACHDEP=	@MACHDEP@
+
+# Multiarch directory (may be empty)
+MULTIARCH=	@MULTIARCH@
+MULTIARCH_CPPFLAGS = @MULTIARCH_CPPFLAGS@
+
+# Install prefix for architecture-independent files
+prefix=		@prefix@
+
+# Install prefix for architecture-dependent files
+exec_prefix=	@exec_prefix@
+
+# Install prefix for data files
+datarootdir=    @datarootdir@
+
+# Expanded directories
+BINDIR=		@bindir@
+LIBDIR=		@libdir@
+MANDIR=		@mandir@
+INCLUDEDIR=	@includedir@
+CONFINCLUDEDIR=	$(exec_prefix)/include
+SCRIPTDIR=	$(prefix)/lib
+ABIFLAGS=	@ABIFLAGS@
+
+# Detailed destination directories
+BINLIBDEST=	$(LIBDIR)/python$(VERSION)
+LIBDEST=	$(SCRIPTDIR)/python$(VERSION)
+INCLUDEPY=	$(INCLUDEDIR)/python$(LDVERSION)
+CONFINCLUDEPY=	$(CONFINCLUDEDIR)/python$(LDVERSION)
+
+# Symbols used for using shared libraries
+SHLIB_SUFFIX=	@SHLIB_SUFFIX@
+EXT_SUFFIX=	@EXT_SUFFIX@
+LDSHARED=	@LDSHARED@ $(PY_LDFLAGS)
+BLDSHARED=	@BLDSHARED@ $(PY_LDFLAGS) $(PY_CFLAGS) $(CCSHARED)
+LDCXXSHARED=	@LDCXXSHARED@
+DESTSHARED=	$(BINLIBDEST)/lib-dynload
+
+# Executable suffix (.exe on Windows and Mac OS X)
+EXE=		@EXEEXT@
+BUILDEXE=	@BUILDEXEEXT@
+
+# Short name and location for Mac OS X Python framework
+UNIVERSALSDK=@UNIVERSALSDK@
+PYTHONFRAMEWORK=	@PYTHONFRAMEWORK@
+PYTHONFRAMEWORKDIR=	@PYTHONFRAMEWORKDIR@
+PYTHONFRAMEWORKPREFIX=	@PYTHONFRAMEWORKPREFIX@
+PYTHONFRAMEWORKINSTALLDIR= @PYTHONFRAMEWORKINSTALLDIR@
+# Deployment target selected during configure, to be checked
+# by distutils. The export statement is needed to ensure that the
+# deployment target is active during build.
+MACOSX_DEPLOYMENT_TARGET=@CONFIGURE_MACOSX_DEPLOYMENT_TARGET@
+@EXPORT_MACOSX_DEPLOYMENT_TARGET@export MACOSX_DEPLOYMENT_TARGET
+
+# Option to install to strip binaries
+STRIPFLAG=-s
+
+# Flags to lipo to produce a 32-bit-only universal executable
+LIPO_32BIT_FLAGS=@LIPO_32BIT_FLAGS@
+
+# Options to enable prebinding (for fast startup prior to Mac OS X 10.3)
+OTHER_LIBTOOL_OPT=@OTHER_LIBTOOL_OPT@
+
+# Environment to run shared python without installed libraries
+RUNSHARED=       @RUNSHARED@
+
+# ensurepip options
+ENSUREPIP=      @ENSUREPIP@
+
+# OpenSSL options for setup.py so sysconfig can pick up AC_SUBST() vars.
+OPENSSL_INCLUDES=@OPENSSL_INCLUDES@
+OPENSSL_LIBS=@OPENSSL_LIBS@
+OPENSSL_LDFLAGS=@OPENSSL_LDFLAGS@
+
+# Modes for directories, executables and data files created by the
+# install process.  Default to user-only-writable for all file types.
+DIRMODE=	755
+EXEMODE=	755
+FILEMODE=	644
+
+# configure script arguments
+CONFIG_ARGS=	@CONFIG_ARGS@
+
+
+# Subdirectories with code
+SRCDIRS= 	@SRCDIRS@
+
+# Other subdirectories
+SUBDIRSTOO=	Include Lib Misc
+
+# Files and directories to be distributed
+CONFIGFILES=	configure configure.ac acconfig.h pyconfig.h.in Makefile.pre.in
+DISTFILES=	README.rst ChangeLog $(CONFIGFILES)
+DISTDIRS=	$(SUBDIRS) $(SUBDIRSTOO) Ext-dummy
+DIST=		$(DISTFILES) $(DISTDIRS)
+
+
+LIBRARY=	@LIBRARY@
+LDLIBRARY=      @LDLIBRARY@
+BLDLIBRARY=     @BLDLIBRARY@
+PY3LIBRARY=     @PY3LIBRARY@
+DLLLIBRARY=	@DLLLIBRARY@
+LDLIBRARYDIR=   @LDLIBRARYDIR@
+INSTSONAME=	@INSTSONAME@
+
+
+LIBS=		@LIBS@
+LIBM=		@LIBM@
+LIBC=		@LIBC@
+SYSLIBS=	$(LIBM) $(LIBC)
+SHLIBS=		@SHLIBS@
+
+DLINCLDIR=	@DLINCLDIR@
+DYNLOADFILE=	@DYNLOADFILE@
+MACHDEP_OBJS=	@MACHDEP_OBJS@
+LIBOBJDIR=	Python/
+LIBOBJS=	@LIBOBJS@
+
+PYTHON=		python$(EXE)
+BUILDPYTHON=	python$(BUILDEXE)
+
+PYTHON_FOR_REGEN=@PYTHON_FOR_REGEN@
+UPDATE_FILE=@PYTHON_FOR_REGEN@ $(srcdir)/Tools/scripts/update_file.py
+PYTHON_FOR_BUILD=@PYTHON_FOR_BUILD@
+_PYTHON_HOST_PLATFORM=@_PYTHON_HOST_PLATFORM@
+BUILD_GNU_TYPE=	@build@
+HOST_GNU_TYPE=	@host@
+
+# Tcl and Tk config info from --with-tcltk-includes and -libs options
+TCLTK_INCLUDES=	@TCLTK_INCLUDES@
+TCLTK_LIBS=	@TCLTK_LIBS@
+
+# The task to run while instrumented when building the profile-opt target.
+# We exclude unittests with -x that take a rediculious amount of time to
+# run in the instrumented training build or do not provide much value.
+PROFILE_TASK=-m test.regrtest --pgo
+
+# report files for gcov / lcov coverage report
+COVERAGE_INFO=	$(abs_builddir)/coverage.info
+COVERAGE_REPORT=$(abs_builddir)/lcov-report
+COVERAGE_REPORT_OPTIONS=--no-branch-coverage --title "CPython lcov report"
+
+
+# === Definitions added by makesetup ===
+
+
+##########################################################################
+# Modules
+MODULE_OBJS=	\
+		Modules/config.o \
+		Modules/getpath.o \
+		Modules/main.o \
+		Modules/gcmodule.o
+
+IO_H=		Modules/_io/_iomodule.h
+
+IO_OBJS=	\
+		Modules/_io/_iomodule.o \
+		Modules/_io/iobase.o \
+		Modules/_io/fileio.o \
+		Modules/_io/bufferedio.o \
+		Modules/_io/textio.o \
+		Modules/_io/bytesio.o \
+		Modules/_io/stringio.o
+
+##########################################################################
+
+LIBFFI_INCLUDEDIR=	@LIBFFI_INCLUDEDIR@
+
+##########################################################################
+# Parser
+PGEN=		Parser/pgen$(EXE)
+
+POBJS=		\
+		Parser/acceler.o \
+		Parser/grammar1.o \
+		Parser/listnode.o \
+		Parser/node.o \
+		Parser/parser.o \
+		Parser/bitset.o \
+		Parser/metagrammar.o \
+		Parser/firstsets.o \
+		Parser/grammar.o \
+		Parser/pgen.o
+
+PARSER_OBJS=	$(POBJS) Parser/myreadline.o Parser/parsetok.o Parser/tokenizer.o
+
+PGOBJS=		\
+		Objects/obmalloc.o \
+		Python/dynamic_annotations.o \
+		Python/mysnprintf.o \
+		Python/pyctype.o \
+		Parser/tokenizer_pgen.o \
+		Parser/printgrammar.o \
+		Parser/parsetok_pgen.o \
+		Parser/pgenmain.o
+
+PARSER_HEADERS= \
+		$(srcdir)/Parser/parser.h \
+		$(srcdir)/Include/parsetok.h \
+		$(srcdir)/Parser/tokenizer.h
+
+PGENOBJS=	$(POBJS) $(PGOBJS)
+
+##########################################################################
+# Python
+
+PYTHON_OBJS=	\
+		Python/_warnings.o \
+		Python/Python-ast.o \
+		Python/asdl.o \
+		Python/ast.o \
+		Python/ast_opt.o \
+		Python/ast_unparse.o \
+		Python/bltinmodule.o \
+		Python/ceval.o \
+		Python/compile.o \
+		Python/codecs.o \
+		Python/dynamic_annotations.o \
+		Python/errors.o \
+		Python/frozenmain.o \
+		Python/future.o \
+		Python/getargs.o \
+		Python/getcompiler.o \
+		Python/getcopyright.o \
+		Python/getplatform.o \
+		Python/getversion.o \
+		Python/graminit.o \
+		Python/import.o \
+		Python/importdl.o \
+		Python/marshal.o \
+		Python/modsupport.o \
+		Python/mysnprintf.o \
+		Python/mystrtoul.o \
+		Python/pathconfig.o \
+		Python/peephole.o \
+		Python/pyarena.o \
+		Python/pyctype.o \
+		Python/pyfpe.o \
+		Python/pyhash.o \
+		Python/pylifecycle.o \
+		Python/pymath.o \
+		Python/pystate.o \
+		Python/context.o \
+		Python/hamt.o \
+		Python/pythonrun.o \
+		Python/pytime.o \
+		Python/bootstrap_hash.o \
+		Python/structmember.o \
+		Python/symtable.o \
+		Python/sysmodule.o \
+		Python/thread.o \
+		Python/traceback.o \
+		Python/getopt.o \
+		Python/pystrcmp.o \
+		Python/pystrtod.o \
+		Python/pystrhex.o \
+		Python/dtoa.o \
+		Python/formatter_unicode.o \
+		Python/fileutils.o \
+		Python/$(DYNLOADFILE) \
+		$(LIBOBJS) \
+		$(MACHDEP_OBJS) \
+		$(DTRACE_OBJS)
+
+
+##########################################################################
+# Objects
+OBJECT_OBJS=	\
+		Objects/abstract.o \
+		Objects/accu.o \
+		Objects/boolobject.o \
+		Objects/bytes_methods.o \
+		Objects/bytearrayobject.o \
+		Objects/bytesobject.o \
+		Objects/call.o \
+		Objects/cellobject.o \
+		Objects/classobject.o \
+		Objects/codeobject.o \
+		Objects/complexobject.o \
+		Objects/descrobject.o \
+		Objects/enumobject.o \
+		Objects/exceptions.o \
+		Objects/genobject.o \
+		Objects/fileobject.o \
+		Objects/floatobject.o \
+		Objects/frameobject.o \
+		Objects/funcobject.o \
+		Objects/iterobject.o \
+		Objects/listobject.o \
+		Objects/longobject.o \
+		Objects/dictobject.o \
+		Objects/odictobject.o \
+		Objects/memoryobject.o \
+		Objects/methodobject.o \
+		Objects/moduleobject.o \
+		Objects/namespaceobject.o \
+		Objects/object.o \
+		Objects/obmalloc.o \
+		Objects/capsule.o \
+		Objects/rangeobject.o \
+		Objects/setobject.o \
+		Objects/sliceobject.o \
+		Objects/structseq.o \
+		Objects/tupleobject.o \
+		Objects/typeobject.o \
+		Objects/unicodeobject.o \
+		Objects/unicodectype.o \
+		Objects/weakrefobject.o
+
+##########################################################################
+# objects that get linked into the Python library
+LIBRARY_OBJS_OMIT_FROZEN=	\
+		Modules/getbuildinfo.o \
+		$(PARSER_OBJS) \
+		$(OBJECT_OBJS) \
+		$(PYTHON_OBJS) \
+		$(MODULE_OBJS) \
+		$(MODOBJS)
+
+LIBRARY_OBJS=	\
+		$(LIBRARY_OBJS_OMIT_FROZEN) \
+		Python/frozen.o
+
+##########################################################################
+# DTrace
+
+# On some systems, object files that reference DTrace probes need to be modified
+# in-place by dtrace(1).
+DTRACE_DEPS = \
+	Python/ceval.o
+# XXX: should gcmodule, etc. be here, too?
+
+#########################################################################
+# Rules
+
+# Default target
+all:		@DEF_MAKE_ALL_RULE@
+build_all:	check-clean-src $(BUILDPYTHON) oldsharedmods sharedmods gdbhooks \
+		Programs/_testembed python-config
+
+# Check that the source is clean when building out of source.
+check-clean-src:
+	@if test -n "$(VPATH)" -a -f "$(srcdir)/Programs/python.o"; then \
+		echo "Error: The source directory ($(srcdir)) is not clean" ; \
+		echo "Building Python out of the source tree (in $(abs_builddir)) requires a clean source tree ($(abs_srcdir))" ; \
+		echo "Try to run: make -C \"$(srcdir)\" clean" ; \
+		exit 1; \
+	fi
+
+# Profile generation build must start from a clean tree.
+profile-clean-stamp:
+	$(MAKE) clean profile-removal
+	touch $@
+
+# Compile with profile generation enabled.
+profile-gen-stamp: profile-clean-stamp
+	@if [ $(LLVM_PROF_ERR) = yes ]; then \
+		echo "Error: Cannot perform PGO build because llvm-profdata was not found in PATH" ;\
+		echo "Please add it to PATH and run ./configure again" ;\
+		exit 1;\
+	fi
+	@echo "Building with support for profile generation:"
+	$(MAKE) build_all_generate_profile
+	touch $@
+
+# Run task with profile generation build to create profile information.
+profile-run-stamp:
+	@echo "Running code to generate profile data (this can take a while):"
+	# First, we need to create a clean build with profile generation
+	# enabled.
+	$(MAKE) profile-gen-stamp
+	# Next, run the profile task to generate the profile information.
+	$(MAKE) run_profile_task
+	$(MAKE) build_all_merge_profile
+	# Remove profile generation binary since we are done with it.
+	$(MAKE) clean
+	# This is an expensive target to build and it does not have proper
+	# makefile dependency information.  So, we create a "stamp" file
+	# to record its completion and avoid re-running it.
+	touch $@
+
+build_all_generate_profile:
+	$(MAKE) @DEF_MAKE_RULE@ CFLAGS_NODIST="$(CFLAGS) $(PGO_PROF_GEN_FLAG)" LDFLAGS="$(LDFLAGS) $(PGO_PROF_GEN_FLAG)" LIBS="$(LIBS)"
+
+run_profile_task:
+	@ # FIXME: can't run for a cross build
+	$(LLVM_PROF_FILE) $(RUNSHARED) ./$(BUILDPYTHON) $(PROFILE_TASK) || true
+	task="$(PROFILE_TASK)"; \
+	case "$$task" in \
+	*-s\ *) \
+	  $(LLVM_PROF_FILE) $(RUNSHARED) ./$(BUILDPYTHON) $$task; \
+	  while [ -f $(abs_builddir)/build/pynexttest ]; do \
+	    $(LLVM_PROF_FILE) $(RUNSHARED) ./$(BUILDPYTHON) $$task; \
+	  done;; \
+	*) \
+	  $(LLVM_PROF_FILE) $(RUNSHARED) ./$(BUILDPYTHON) $$task; \
+	esac
+
+build_all_merge_profile:
+	$(LLVM_PROF_MERGER)
+
+# Compile Python binary with profile guided optimization.
+# To force re-running of the profile task, remove the profile-run-stamp file.
+profile-opt: profile-run-stamp
+	@echo "Rebuilding with profile guided optimizations:"
+	-rm -f profile-clean-stamp
+	$(MAKE) @DEF_MAKE_RULE@ CFLAGS_NODIST="$(CFLAGS) $(PGO_PROF_USE_FLAG)" LDFLAGS="$(LDFLAGS)"
+
+# Compile and run with gcov
+.PHONY=coverage coverage-lcov coverage-report
+coverage:
+	@echo "Building with support for coverage checking:"
+	$(MAKE) clean profile-removal
+	$(MAKE) @DEF_MAKE_RULE@ CFLAGS="$(CFLAGS) -O0 -pg -fprofile-arcs -ftest-coverage" LIBS="$(LIBS) -lgcov"
+
+coverage-lcov:
+	@echo "Creating Coverage HTML report with LCOV:"
+	@rm -f $(COVERAGE_INFO)
+	@rm -rf $(COVERAGE_REPORT)
+	@lcov --capture --directory $(abs_builddir) \
+	    --base-directory $(realpath $(abs_builddir)) \
+	    --path $(realpath $(abs_srcdir)) \
+	    --output-file $(COVERAGE_INFO)
+	@ # remove 3rd party modules, system headers and internal files with
+	@ # debug, test or dummy functions.
+	@lcov --remove $(COVERAGE_INFO) \
+	    '*/Modules/_blake2/impl/*' \
+	    '*/Modules/_ctypes/libffi*/*' \
+	    '*/Modules/_decimal/libmpdec/*' \
+	    '*/Modules/_sha3/kcp/*' \
+	    '*/Modules/expat/*' \
+	    '*/Modules/zlib/*' \
+	    '*/Include/*' \
+	    '*/Modules/xx*.c' \
+	    '*/Parser/listnode.c' \
+	    '*/Python/pyfpe.c' \
+	    '*/Python/pystrcmp.c' \
+	    '/usr/include/*' \
+	    '/usr/local/include/*' \
+	    '/usr/lib/gcc/*' \
+	    --output-file $(COVERAGE_INFO)
+	@genhtml $(COVERAGE_INFO) --output-directory $(COVERAGE_REPORT) \
+	    $(COVERAGE_REPORT_OPTIONS)
+	@echo
+	@echo "lcov report at $(COVERAGE_REPORT)/index.html"
+	@echo
+
+# Force regeneration of parser and importlib
+coverage-report: regen-grammar regen-importlib
+	@ # build with coverage info
+	$(MAKE) coverage
+	@ # run tests, ignore failures
+	$(TESTRUNNER) $(TESTOPTS) || true
+	@ # build lcov report
+	$(MAKE) coverage-lcov
+
+# Run "Argument Clinic" over all source files
+.PHONY=clinic
+clinic: check-clean-src $(srcdir)/Modules/_blake2/blake2s_impl.c
+	$(PYTHON_FOR_REGEN) $(srcdir)/Tools/clinic/clinic.py --make --srcdir $(srcdir)
+
+# Build the interpreter
+$(BUILDPYTHON):	Programs/python.o $(LIBRARY) $(LDLIBRARY) $(PY3LIBRARY)
+	$(LINKCC) $(PY_LDFLAGS) $(PY_CFLAGS) $(LINKFORSHARED) -o $@ Programs/python.o $(BLDLIBRARY) $(LIBS) $(MODLIBS) $(SYSLIBS) $(LDLAST)
+
+platform: $(BUILDPYTHON) pybuilddir.txt
+	$(RUNSHARED) $(PYTHON_FOR_BUILD) -c 'import sys ; from sysconfig import get_platform ; print("%s-%d.%d" % (get_platform(), *sys.version_info[:2]))' >platform
+
+# Create build directory and generate the sysconfig build-time data there.
+# pybuilddir.txt contains the name of the build dir and is used for
+# sys.path fixup -- see Modules/getpath.c.
+# Since this step runs before shared modules are built, try to avoid bootstrap
+# problems by creating a dummy pybuilddir.txt just to allow interpreter
+# initialization to succeed.  It will be overwritten by generate-posix-vars
+# or removed in case of failure.
+pybuilddir.txt: $(BUILDPYTHON)
+	@echo "none" > ./pybuilddir.txt
+	$(RUNSHARED) $(PYTHON_FOR_BUILD) -S -m sysconfig --generate-posix-vars ;\
+	if test $$? -ne 0 ; then \
+		echo "generate-posix-vars failed" ; \
+		rm -f ./pybuilddir.txt ; \
+		exit 1 ; \
+	fi
+
+# This is shared by the math and cmath modules
+# don't build with -fPIC when building as math and cmath as builtins
+Modules/_math.o: Modules/_math.c Modules/_math.h
+	$(CC) -c $(if $(findstring _math.o, $(MODOBJS)),,$(CCSHARED)) $(PY_CORE_CFLAGS) -o $@ $<
+
+# blake2s is auto-generated from blake2b
+$(srcdir)/Modules/_blake2/blake2s_impl.c: $(srcdir)/Modules/_blake2/blake2b_impl.c $(srcdir)/Modules/_blake2/blake2b2s.py
+	$(PYTHON_FOR_REGEN) $(srcdir)/Modules/_blake2/blake2b2s.py
+	$(PYTHON_FOR_REGEN) $(srcdir)/Tools/clinic/clinic.py -f $@
+
+# Build the shared modules
+# Under GNU make, MAKEFLAGS are sorted and normalized; the 's' for
+# -s, --silent or --quiet is always the first char.
+# Under BSD make, MAKEFLAGS might be " -s -v x=y".
+# Ignore macros passed by GNU make, passed after --
+sharedmods: $(BUILDPYTHON) pybuilddir.txt Modules/_math.o
+	@case "`echo X $$MAKEFLAGS | sed 's/^X //;s/ -- .*//'`" in \
+	    *\ -s*|s*) quiet="-q";; \
+	    *) quiet="";; \
+	esac; \
+	echo "$(RUNSHARED) CC='$(CC)' LDSHARED='$(BLDSHARED)' OPT='$(OPT)' \
+		_TCLTK_INCLUDES='$(TCLTK_INCLUDES)' _TCLTK_LIBS='$(TCLTK_LIBS)' \
+		$(PYTHON_FOR_BUILD) $(srcdir)/setup.py $$quiet build"; \
+	$(RUNSHARED) CC='$(CC)' LDSHARED='$(BLDSHARED)' OPT='$(OPT)' \
+		_TCLTK_INCLUDES='$(TCLTK_INCLUDES)' _TCLTK_LIBS='$(TCLTK_LIBS)' \
+		$(PYTHON_FOR_BUILD) $(srcdir)/setup.py $$quiet build
+
+
+# Build static library
+$(LIBRARY): $(LIBRARY_OBJS)
+	-rm -f $@
+	$(AR) $(ARFLAGS) $@ $(LIBRARY_OBJS)
+
+libpython$(LDVERSION).so: $(LIBRARY_OBJS)
+	if test $(INSTSONAME) != $(LDLIBRARY); then \
+		$(BLDSHARED) -Wl,-h$(INSTSONAME) -o $(INSTSONAME) $(LIBRARY_OBJS) $(MODLIBS) $(SHLIBS) $(LIBC) $(LIBM) $(LDLAST); \
+		$(LN) -f $(INSTSONAME) $@; \
+	else \
+		$(BLDSHARED) -o $@ $(LIBRARY_OBJS) $(MODLIBS) $(SHLIBS) $(LIBC) $(LIBM) $(LDLAST); \
+	fi
+
+libpython3.so:	libpython$(LDVERSION).so
+	$(BLDSHARED) $(NO_AS_NEEDED) -o $@ -Wl,-h$@ $^
+
+libpython$(LDVERSION).dylib: $(LIBRARY_OBJS)
+	 $(CC) -dynamiclib -Wl,-single_module $(PY_LDFLAGS) -undefined dynamic_lookup -Wl,-install_name,$(prefix)/lib/libpython$(LDVERSION).dylib -Wl,-compatibility_version,$(VERSION) -Wl,-current_version,$(VERSION) -o $@ $(LIBRARY_OBJS) $(SHLIBS) $(LIBC) $(LIBM) $(LDLAST); \
+
+
+libpython$(VERSION).sl: $(LIBRARY_OBJS)
+	$(LDSHARED) -o $@ $(LIBRARY_OBJS) $(MODLIBS) $(SHLIBS) $(LIBC) $(LIBM) $(LDLAST)
+
+# Copy up the gdb python hooks into a position where they can be automatically
+# loaded by gdb during Lib/test/test_gdb.py
+#
+# Distributors are likely to want to install this somewhere else e.g. relative
+# to the stripped DWARF data for the shared library.
+gdbhooks: $(BUILDPYTHON)-gdb.py
+
+SRC_GDB_HOOKS=$(srcdir)/Tools/gdb/libpython.py
+$(BUILDPYTHON)-gdb.py: $(SRC_GDB_HOOKS)
+	$(INSTALL_DATA) $(SRC_GDB_HOOKS) $(BUILDPYTHON)-gdb.py
+
+# This rule is here for OPENSTEP/Rhapsody/MacOSX. It builds a temporary
+# minimal framework (not including the Lib directory and such) in the current
+# directory.
+RESSRCDIR=Mac/Resources/framework
+$(PYTHONFRAMEWORKDIR)/Versions/$(VERSION)/$(PYTHONFRAMEWORK): \
+		$(LIBRARY) \
+		$(RESSRCDIR)/Info.plist
+	$(INSTALL) -d -m $(DIRMODE) $(PYTHONFRAMEWORKDIR)/Versions/$(VERSION)
+	$(CC) -o $(LDLIBRARY) $(PY_LDFLAGS) -dynamiclib \
+		-all_load $(LIBRARY) -Wl,-single_module \
+		-install_name $(DESTDIR)$(PYTHONFRAMEWORKINSTALLDIR)/Versions/$(VERSION)/$(PYTHONFRAMEWORK) \
+		-compatibility_version $(VERSION) \
+		-current_version $(VERSION) \
+		-framework CoreFoundation $(LIBS);
+	$(INSTALL) -d -m $(DIRMODE)  \
+		$(PYTHONFRAMEWORKDIR)/Versions/$(VERSION)/Resources/English.lproj
+	$(INSTALL_DATA) $(RESSRCDIR)/Info.plist \
+		$(PYTHONFRAMEWORKDIR)/Versions/$(VERSION)/Resources/Info.plist
+	$(LN) -fsn $(VERSION) $(PYTHONFRAMEWORKDIR)/Versions/Current
+	$(LN) -fsn Versions/Current/$(PYTHONFRAMEWORK) $(PYTHONFRAMEWORKDIR)/$(PYTHONFRAMEWORK)
+	$(LN) -fsn Versions/Current/Resources $(PYTHONFRAMEWORKDIR)/Resources
+
+# This rule builds the Cygwin Python DLL and import library if configured
+# for a shared core library; otherwise, this rule is a noop.
+$(DLLLIBRARY) libpython$(LDVERSION).dll.a: $(LIBRARY_OBJS)
+	if test -n "$(DLLLIBRARY)"; then \
+		$(LDSHARED) -Wl,--out-implib=$@ -o $(DLLLIBRARY) $^ \
+			$(LIBS) $(MODLIBS) $(SYSLIBS) $(LDLAST); \
+	else true; \
+	fi
+
+
+oldsharedmods: $(SHAREDMODS)
+
+
+Makefile Modules/config.c: Makefile.pre \
+				$(srcdir)/Modules/config.c.in \
+				$(MAKESETUP) \
+				Modules/Setup \
+				Modules/Setup.local
+	$(SHELL) $(MAKESETUP) -c $(srcdir)/Modules/config.c.in \
+				-s Modules \
+				Modules/Setup.local \
+				Modules/Setup
+	@mv config.c Modules
+	@echo "The Makefile was updated, you may need to re-run make."
+
+
+Modules/Setup: $(srcdir)/Modules/Setup.dist
+	@if test -f Modules/Setup; then \
+		echo "-----------------------------------------------"; \
+		echo "Modules/Setup.dist is newer than Modules/Setup;"; \
+		echo "check to make sure you have all the updates you"; \
+		echo "need in your Modules/Setup file."; \
+		echo "Usually, copying Modules/Setup.dist to Modules/Setup will work."; \
+		echo "-----------------------------------------------"; \
+	fi
+
+Programs/_testembed: Programs/_testembed.o $(LIBRARY) $(LDLIBRARY) $(PY3LIBRARY)
+	$(LINKCC) $(PY_LDFLAGS) $(LINKFORSHARED) -o $@ Programs/_testembed.o $(BLDLIBRARY) $(LIBS) $(MODLIBS) $(SYSLIBS) $(LDLAST)
+
+############################################################################
+# Importlib
+
+Programs/_freeze_importlib.o: Programs/_freeze_importlib.c Makefile
+
+Programs/_freeze_importlib: Programs/_freeze_importlib.o $(LIBRARY_OBJS_OMIT_FROZEN)
+	$(LINKCC) $(PY_LDFLAGS) -o $@ Programs/_freeze_importlib.o $(LIBRARY_OBJS_OMIT_FROZEN) $(LIBS) $(MODLIBS) $(SYSLIBS) $(LDLAST)
+
+.PHONY: regen-importlib
+regen-importlib: Programs/_freeze_importlib
+	# Regenerate Python/importlib_external.h
+	# from Lib/importlib/_bootstrap_external.py using _freeze_importlib
+	./Programs/_freeze_importlib \
+	    $(srcdir)/Lib/importlib/_bootstrap_external.py \
+	    $(srcdir)/Python/importlib_external.h.new
+	$(UPDATE_FILE) $(srcdir)/Python/importlib_external.h $(srcdir)/Python/importlib_external.h.new
+	# Regenerate Python/importlib.h from Lib/importlib/_bootstrap.py
+	# using _freeze_importlib
+	./Programs/_freeze_importlib \
+	    $(srcdir)/Lib/importlib/_bootstrap.py \
+	    $(srcdir)/Python/importlib.h.new
+	$(UPDATE_FILE) $(srcdir)/Python/importlib.h $(srcdir)/Python/importlib.h.new
+
+
+############################################################################
+# Regenerate all generated files
+
+regen-all: regen-opcode regen-opcode-targets regen-typeslots regen-grammar \
+	regen-ast regen-importlib clinic
+
+############################################################################
+# Special rules for object files
+
+Modules/getbuildinfo.o: $(PARSER_OBJS) \
+		$(OBJECT_OBJS) \
+		$(PYTHON_OBJS) \
+		$(MODULE_OBJS) \
+		$(MODOBJS) \
+		$(srcdir)/Modules/getbuildinfo.c
+	$(CC) -c $(PY_CORE_CFLAGS) \
+	      -DGITVERSION="\"`LC_ALL=C $(GITVERSION)`\"" \
+	      -DGITTAG="\"`LC_ALL=C $(GITTAG)`\"" \
+	      -DGITBRANCH="\"`LC_ALL=C $(GITBRANCH)`\"" \
+	      $(if $(BUILD_DATE),-DDATE='"$(BUILD_DATE)"') \
+	      $(if $(BUILD_TIME),-DTIME='"$(BUILD_TIME)"') \
+	      -o $@ $(srcdir)/Modules/getbuildinfo.c
+
+Modules/getpath.o: $(srcdir)/Modules/getpath.c Makefile
+	$(CC) -c $(PY_CORE_CFLAGS) -DPYTHONPATH='"$(PYTHONPATH)"' \
+		-DPREFIX='"$(prefix)"' \
+		-DEXEC_PREFIX='"$(exec_prefix)"' \
+		-DVERSION='"$(VERSION)"' \
+		-DVPATH='"$(VPATH)"' \
+		-o $@ $(srcdir)/Modules/getpath.c
+
+Programs/python.o: $(srcdir)/Programs/python.c
+	$(MAINCC) -c $(PY_CORE_CFLAGS) -o $@ $(srcdir)/Programs/python.c
+
+Programs/_testembed.o: $(srcdir)/Programs/_testembed.c
+	$(MAINCC) -c $(PY_CORE_CFLAGS) -o $@ $(srcdir)/Programs/_testembed.c
+
+Modules/_sre.o: $(srcdir)/Modules/_sre.c $(srcdir)/Modules/sre.h $(srcdir)/Modules/sre_constants.h $(srcdir)/Modules/sre_lib.h
+
+Modules/posixmodule.o: $(srcdir)/Modules/posixmodule.c $(srcdir)/Modules/posixmodule.h
+
+Modules/grpmodule.o: $(srcdir)/Modules/grpmodule.c $(srcdir)/Modules/posixmodule.h
+
+Modules/pwdmodule.o: $(srcdir)/Modules/pwdmodule.c $(srcdir)/Modules/posixmodule.h
+
+Modules/signalmodule.o: $(srcdir)/Modules/signalmodule.c $(srcdir)/Modules/posixmodule.h
+
+Python/dynload_shlib.o: $(srcdir)/Python/dynload_shlib.c Makefile
+	$(CC) -c $(PY_CORE_CFLAGS) \
+		$(if $(MULTIARCH),-DMULTIARCH='"$(MULTIARCH)"') \
+		-DSOABI='"$(SOABI)"' \
+		-o $@ $(srcdir)/Python/dynload_shlib.c
+
+Python/dynload_hpux.o: $(srcdir)/Python/dynload_hpux.c Makefile
+	$(CC) -c $(PY_CORE_CFLAGS) \
+		-DSHLIB_EXT='"$(EXT_SUFFIX)"' \
+		-o $@ $(srcdir)/Python/dynload_hpux.c
+
+Python/sysmodule.o: $(srcdir)/Python/sysmodule.c Makefile
+	$(CC) -c $(PY_CORE_CFLAGS) \
+		-DABIFLAGS='"$(ABIFLAGS)"' \
+		$(MULTIARCH_CPPFLAGS) \
+		-o $@ $(srcdir)/Python/sysmodule.c
+
+$(IO_OBJS): $(IO_H)
+
+$(PGEN): $(PGENOBJS)
+		$(CC) $(OPT) $(PY_LDFLAGS) $(PGENOBJS) $(LIBS) -o $(PGEN)
+
+.PHONY: regen-grammar
+regen-grammar: $(PGEN)
+	# Regenerate Include/graminit.h and Python/graminit.c
+	# from Grammar/Grammar using pgen
+	@$(MKDIR_P) Include
+	$(PGEN) $(srcdir)/Grammar/Grammar \
+		$(srcdir)/Include/graminit.h.new \
+		$(srcdir)/Python/graminit.c.new
+	$(UPDATE_FILE) $(srcdir)/Include/graminit.h $(srcdir)/Include/graminit.h.new
+	$(UPDATE_FILE) $(srcdir)/Python/graminit.c $(srcdir)/Python/graminit.c.new
+
+Parser/grammar.o:	$(srcdir)/Parser/grammar.c \
+				$(srcdir)/Include/token.h \
+				$(srcdir)/Include/grammar.h
+Parser/metagrammar.o:	$(srcdir)/Parser/metagrammar.c
+
+Parser/tokenizer_pgen.o:	$(srcdir)/Parser/tokenizer.c
+Parser/parsetok_pgen.o:	$(srcdir)/Parser/parsetok.c
+Parser/printgrammar.o: $(srcdir)/Parser/printgrammar.c
+
+Parser/pgenmain.o:	$(srcdir)/Include/parsetok.h
+
+.PHONY=regen-ast
+regen-ast:
+	# Regenerate Include/Python-ast.h using Parser/asdl_c.py -h
+	$(MKDIR_P) $(srcdir)/Include
+	$(PYTHON_FOR_REGEN) $(srcdir)/Parser/asdl_c.py \
+		-h $(srcdir)/Include/Python-ast.h.new \
+		$(srcdir)/Parser/Python.asdl
+	$(UPDATE_FILE) $(srcdir)/Include/Python-ast.h $(srcdir)/Include/Python-ast.h.new
+	# Regenerate Python/Python-ast.c using Parser/asdl_c.py -c
+	$(MKDIR_P) $(srcdir)/Python
+	$(PYTHON_FOR_REGEN) $(srcdir)/Parser/asdl_c.py \
+		-c $(srcdir)/Python/Python-ast.c.new \
+		$(srcdir)/Parser/Python.asdl
+	$(UPDATE_FILE) $(srcdir)/Python/Python-ast.c $(srcdir)/Python/Python-ast.c.new
+
+.PHONY: regen-opcode
+regen-opcode:
+	# Regenerate Include/opcode.h from Lib/opcode.py
+	# using Tools/scripts/generate_opcode_h.py
+	$(PYTHON_FOR_REGEN) $(srcdir)/Tools/scripts/generate_opcode_h.py \
+		$(srcdir)/Lib/opcode.py \
+		$(srcdir)/Include/opcode.h.new
+	$(UPDATE_FILE) $(srcdir)/Include/opcode.h $(srcdir)/Include/opcode.h.new
+
+Python/compile.o Python/symtable.o Python/ast_unparse.o Python/ast.o: $(srcdir)/Include/graminit.h $(srcdir)/Include/Python-ast.h
+
+Python/getplatform.o: $(srcdir)/Python/getplatform.c
+		$(CC) -c $(PY_CORE_CFLAGS) -DPLATFORM='"$(MACHDEP)"' -o $@ $(srcdir)/Python/getplatform.c
+
+Python/importdl.o: $(srcdir)/Python/importdl.c
+		$(CC) -c $(PY_CORE_CFLAGS) -I$(DLINCLDIR) -o $@ $(srcdir)/Python/importdl.c
+
+Objects/unicodectype.o:	$(srcdir)/Objects/unicodectype.c \
+				$(srcdir)/Objects/unicodetype_db.h
+
+BYTESTR_DEPS = \
+		$(srcdir)/Objects/stringlib/count.h \
+		$(srcdir)/Objects/stringlib/ctype.h \
+		$(srcdir)/Objects/stringlib/fastsearch.h \
+		$(srcdir)/Objects/stringlib/find.h \
+		$(srcdir)/Objects/stringlib/join.h \
+		$(srcdir)/Objects/stringlib/partition.h \
+		$(srcdir)/Objects/stringlib/split.h \
+		$(srcdir)/Objects/stringlib/stringdefs.h \
+		$(srcdir)/Objects/stringlib/transmogrify.h
+
+UNICODE_DEPS = \
+		$(srcdir)/Objects/stringlib/asciilib.h \
+		$(srcdir)/Objects/stringlib/codecs.h \
+		$(srcdir)/Objects/stringlib/count.h \
+		$(srcdir)/Objects/stringlib/fastsearch.h \
+		$(srcdir)/Objects/stringlib/find.h \
+		$(srcdir)/Objects/stringlib/find_max_char.h \
+		$(srcdir)/Objects/stringlib/localeutil.h \
+		$(srcdir)/Objects/stringlib/partition.h \
+		$(srcdir)/Objects/stringlib/replace.h \
+		$(srcdir)/Objects/stringlib/split.h \
+		$(srcdir)/Objects/stringlib/ucs1lib.h \
+		$(srcdir)/Objects/stringlib/ucs2lib.h \
+		$(srcdir)/Objects/stringlib/ucs4lib.h \
+		$(srcdir)/Objects/stringlib/undef.h \
+		$(srcdir)/Objects/stringlib/unicode_format.h \
+		$(srcdir)/Objects/stringlib/unicodedefs.h
+
+Objects/bytes_methods.o: $(srcdir)/Objects/bytes_methods.c $(BYTESTR_DEPS)
+Objects/bytesobject.o: $(srcdir)/Objects/bytesobject.c $(BYTESTR_DEPS)
+Objects/bytearrayobject.o: $(srcdir)/Objects/bytearrayobject.c $(BYTESTR_DEPS)
+
+Objects/unicodeobject.o: $(srcdir)/Objects/unicodeobject.c $(UNICODE_DEPS)
+
+Objects/odictobject.o: $(srcdir)/Objects/dict-common.h
+Objects/dictobject.o: $(srcdir)/Objects/stringlib/eq.h $(srcdir)/Objects/dict-common.h
+Objects/setobject.o: $(srcdir)/Objects/stringlib/eq.h
+
+.PHONY: regen-opcode-targets
+regen-opcode-targets:
+	# Regenerate Python/opcode_targets.h from Lib/opcode.py
+	# using Python/makeopcodetargets.py
+	$(PYTHON_FOR_REGEN) $(srcdir)/Python/makeopcodetargets.py \
+		$(srcdir)/Python/opcode_targets.h.new
+	$(UPDATE_FILE) $(srcdir)/Python/opcode_targets.h $(srcdir)/Python/opcode_targets.h.new
+
+Python/ceval.o: $(srcdir)/Python/opcode_targets.h $(srcdir)/Python/ceval_gil.h
+
+Python/frozen.o: $(srcdir)/Python/importlib.h $(srcdir)/Python/importlib_external.h
+
+# Generate DTrace probe macros, then rename them (PYTHON_ -> PyDTrace_) to
+# follow our naming conventions. dtrace(1) uses the output filename to generate
+# an include guard, so we can't use a pipeline to transform its output.
+Include/pydtrace_probes.h: $(srcdir)/Include/pydtrace.d
+	$(MKDIR_P) Include
+	$(DTRACE) $(DFLAGS) -o $@ -h -s $<
+	: sed in-place edit with POSIX-only tools
+	sed 's/PYTHON_/PyDTrace_/' $@ > $@.tmp
+	mv $@.tmp $@
+
+Python/pydtrace.o: $(srcdir)/Include/pydtrace.d $(DTRACE_DEPS)
+	$(DTRACE) $(DFLAGS) -o $@ -G -s $< $(DTRACE_DEPS)
+
+Objects/typeobject.o: Objects/typeslots.inc
+
+.PHONY: regen-typeslots
+regen-typeslots:
+	# Regenerate Objects/typeslots.inc from Include/typeslotsh
+	# using Objects/typeslots.py
+	$(PYTHON_FOR_REGEN) $(srcdir)/Objects/typeslots.py \
+		< $(srcdir)/Include/typeslots.h \
+		$(srcdir)/Objects/typeslots.inc.new
+	$(UPDATE_FILE) $(srcdir)/Objects/typeslots.inc $(srcdir)/Objects/typeslots.inc.new
+
+############################################################################
+# Header files
+
+PYTHON_HEADERS= \
+		$(srcdir)/Include/Python.h \
+		$(srcdir)/Include/abstract.h \
+		$(srcdir)/Include/accu.h \
+		$(srcdir)/Include/asdl.h \
+		$(srcdir)/Include/ast.h \
+		$(srcdir)/Include/bltinmodule.h \
+		$(srcdir)/Include/bitset.h \
+		$(srcdir)/Include/boolobject.h \
+		$(srcdir)/Include/bytes_methods.h \
+		$(srcdir)/Include/bytearrayobject.h \
+		$(srcdir)/Include/bytesobject.h \
+		$(srcdir)/Include/cellobject.h \
+		$(srcdir)/Include/ceval.h \
+		$(srcdir)/Include/classobject.h \
+		$(srcdir)/Include/code.h \
+		$(srcdir)/Include/codecs.h \
+		$(srcdir)/Include/compile.h \
+		$(srcdir)/Include/complexobject.h \
+		$(srcdir)/Include/descrobject.h \
+		$(srcdir)/Include/dictobject.h \
+		$(srcdir)/Include/dtoa.h \
+		$(srcdir)/Include/dynamic_annotations.h \
+		$(srcdir)/Include/enumobject.h \
+		$(srcdir)/Include/errcode.h \
+		$(srcdir)/Include/eval.h \
+		$(srcdir)/Include/fileobject.h \
+		$(srcdir)/Include/fileutils.h \
+		$(srcdir)/Include/floatobject.h \
+		$(srcdir)/Include/frameobject.h \
+		$(srcdir)/Include/funcobject.h \
+		$(srcdir)/Include/genobject.h \
+		$(srcdir)/Include/import.h \
+		$(srcdir)/Include/intrcheck.h \
+		$(srcdir)/Include/iterobject.h \
+		$(srcdir)/Include/listobject.h \
+		$(srcdir)/Include/longintrepr.h \
+		$(srcdir)/Include/longobject.h \
+		$(srcdir)/Include/marshal.h \
+		$(srcdir)/Include/memoryobject.h \
+		$(srcdir)/Include/metagrammar.h \
+		$(srcdir)/Include/methodobject.h \
+		$(srcdir)/Include/modsupport.h \
+		$(srcdir)/Include/moduleobject.h \
+		$(srcdir)/Include/namespaceobject.h \
+		$(srcdir)/Include/node.h \
+		$(srcdir)/Include/object.h \
+		$(srcdir)/Include/objimpl.h \
+		$(srcdir)/Include/opcode.h \
+		$(srcdir)/Include/osdefs.h \
+		$(srcdir)/Include/osmodule.h \
+		$(srcdir)/Include/patchlevel.h \
+		$(srcdir)/Include/pgen.h \
+		$(srcdir)/Include/pgenheaders.h \
+		$(srcdir)/Include/pyarena.h \
+		$(srcdir)/Include/pyatomic.h \
+		$(srcdir)/Include/pycapsule.h \
+		$(srcdir)/Include/pyctype.h \
+		$(srcdir)/Include/pydebug.h \
+		$(srcdir)/Include/pydtrace.h \
+		$(srcdir)/Include/pyerrors.h \
+		$(srcdir)/Include/pyfpe.h \
+		$(srcdir)/Include/pyhash.h \
+		$(srcdir)/Include/pylifecycle.h \
+		$(srcdir)/Include/pymath.h \
+		$(srcdir)/Include/pymacro.h \
+		$(srcdir)/Include/pymem.h \
+		$(srcdir)/Include/pyport.h \
+		$(srcdir)/Include/pystate.h \
+		$(srcdir)/Include/context.h \
+		$(srcdir)/Include/pystrcmp.h \
+		$(srcdir)/Include/pystrtod.h \
+		$(srcdir)/Include/pystrhex.h \
+		$(srcdir)/Include/pythonrun.h \
+		$(srcdir)/Include/pythread.h \
+		$(srcdir)/Include/pytime.h \
+		$(srcdir)/Include/rangeobject.h \
+		$(srcdir)/Include/setobject.h \
+		$(srcdir)/Include/sliceobject.h \
+		$(srcdir)/Include/structmember.h \
+		$(srcdir)/Include/structseq.h \
+		$(srcdir)/Include/symtable.h \
+		$(srcdir)/Include/sysmodule.h \
+		$(srcdir)/Include/traceback.h \
+		$(srcdir)/Include/tupleobject.h \
+		$(srcdir)/Include/ucnhash.h \
+		$(srcdir)/Include/unicodeobject.h \
+		$(srcdir)/Include/warnings.h \
+		$(srcdir)/Include/weakrefobject.h \
+		pyconfig.h \
+		$(PARSER_HEADERS) \
+		$(srcdir)/Include/Python-ast.h \
+		$(srcdir)/Include/internal/ceval.h \
+		$(srcdir)/Include/internal/gil.h \
+		$(srcdir)/Include/internal/mem.h \
+		$(srcdir)/Include/internal/pygetopt.h \
+		$(srcdir)/Include/internal/pystate.h \
+		$(srcdir)/Include/internal/context.h \
+		$(srcdir)/Include/internal/warnings.h \
+		$(DTRACE_HEADERS)
+
+$(LIBRARY_OBJS) $(MODOBJS) Programs/python.o: $(PYTHON_HEADERS)
+
+
+######################################################################
+
+TESTOPTS=	$(EXTRATESTOPTS)
+TESTPYTHON=	$(RUNSHARED) ./$(BUILDPYTHON) $(TESTPYTHONOPTS)
+TESTRUNNER=	$(TESTPYTHON) $(srcdir)/Tools/scripts/run_tests.py
+TESTTIMEOUT=	1200
+
+.PHONY: test testall testuniversal buildbottest pythoninfo
+
+# Run a basic set of regression tests.
+# This excludes some tests that are particularly resource-intensive.
+test:		@DEF_MAKE_RULE@ platform
+		$(TESTRUNNER) $(TESTOPTS)
+
+# Run the full test suite twice - once without .pyc files, and once with.
+# In the past, we've had problems where bugs in the marshalling or
+# elsewhere caused bytecode read from .pyc files to behave differently
+# than bytecode generated directly from a .py source file.  Sometimes
+# the bytecode read from a .pyc file had the bug, sometimes the directly
+# generated bytecode.  This is sometimes a very shy bug needing a lot of
+# sample data.
+testall:	@DEF_MAKE_RULE@ platform
+		-find $(srcdir)/Lib -name '*.py[co]' -print | xargs rm -f
+		$(TESTPYTHON) -E $(srcdir)/Lib/compileall.py
+		-find $(srcdir)/Lib -name '*.py[co]' -print | xargs rm -f
+		-$(TESTRUNNER) -u all $(TESTOPTS)
+		$(TESTRUNNER) -u all $(TESTOPTS)
+
+# Run the test suite for both architectures in a Universal build on OSX.
+# Must be run on an Intel box.
+testuniversal:	@DEF_MAKE_RULE@ platform
+		@if [ `arch` != 'i386' ]; then \
+			echo "This can only be used on OSX/i386" ;\
+			exit 1 ;\
+		fi
+		$(TESTRUNNER) -u all $(TESTOPTS)
+		$(RUNSHARED) /usr/libexec/oah/translate \
+			./$(BUILDPYTHON) -E -m test -j 0 -u all $(TESTOPTS)
+
+# Like testall, but with only one pass and without multiple processes.
+# Run an optional script to include information about the build environment.
+buildbottest:	build_all platform
+		-@if which pybuildbot.identify >/dev/null 2>&1; then \
+			pybuildbot.identify "CC='$(CC)'" "CXX='$(CXX)'"; \
+		fi
+		$(TESTRUNNER) -j 1 -u all -W --slowest --fail-env-changed --timeout=$(TESTTIMEOUT) $(TESTOPTS)
+
+pythoninfo: build_all
+		$(RUNSHARED) ./$(BUILDPYTHON) -m test.pythoninfo
+
+QUICKTESTOPTS=	$(TESTOPTS) -x test_subprocess test_io test_lib2to3 \
+		test_multibytecodec test_urllib2_localnet test_itertools \
+		test_multiprocessing_fork test_multiprocessing_spawn \
+		test_multiprocessing_forkserver \
+		test_mailbox test_socket test_poll \
+		test_select test_zipfile test_concurrent_futures
+quicktest:	@DEF_MAKE_RULE@ platform
+		$(TESTRUNNER) $(QUICKTESTOPTS)
+
+# SSL tests
+.PHONY: multisslcompile multissltest
+multisslcompile: build_all
+	$(RUNSHARED) ./$(BUILDPYTHON) Tools/ssl/multissltests.py --steps=modules
+
+multissltest: build_all
+	$(RUNSHARED) ./$(BUILDPYTHON) Tools/ssl/multissltests.py
+
+install: @FRAMEWORKINSTALLFIRST@ commoninstall bininstall maninstall @FRAMEWORKINSTALLLAST@
+	if test "x$(ENSUREPIP)" != "xno"  ; then \
+		case $(ENSUREPIP) in \
+			upgrade) ensurepip="--upgrade" ;; \
+			install|*) ensurepip="" ;; \
+		esac; \
+		$(RUNSHARED) $(PYTHON_FOR_BUILD) -m ensurepip \
+			$$ensurepip --root=$(DESTDIR)/ ; \
+	fi
+
+altinstall: commoninstall
+	if test "x$(ENSUREPIP)" != "xno"  ; then \
+		case $(ENSUREPIP) in \
+			upgrade) ensurepip="--altinstall --upgrade" ;; \
+			install|*) ensurepip="--altinstall" ;; \
+		esac; \
+		$(RUNSHARED) $(PYTHON_FOR_BUILD) -m ensurepip \
+			$$ensurepip --root=$(DESTDIR)/ ; \
+	fi
+
+commoninstall:  check-clean-src @FRAMEWORKALTINSTALLFIRST@ \
+		altbininstall libinstall inclinstall libainstall \
+		sharedinstall oldsharedinstall altmaninstall \
+		@FRAMEWORKALTINSTALLLAST@
+
+# Install shared libraries enabled by Setup
+DESTDIRS=	$(exec_prefix) $(LIBDIR) $(BINLIBDEST) $(DESTSHARED)
+
+oldsharedinstall: $(DESTSHARED) $(SHAREDMODS)
+		@for i in X $(SHAREDMODS); do \
+		  if test $$i != X; then \
+		    echo $(INSTALL_SHARED) $$i $(DESTSHARED)/`basename $$i`; \
+		    $(INSTALL_SHARED) $$i $(DESTDIR)$(DESTSHARED)/`basename $$i`; \
+		  fi; \
+		done
+
+$(DESTSHARED):
+		@for i in $(DESTDIRS); \
+		do \
+			if test ! -d $(DESTDIR)$$i; then \
+				echo "Creating directory $$i"; \
+				$(INSTALL) -d -m $(DIRMODE) $(DESTDIR)$$i; \
+			else    true; \
+			fi; \
+		done
+
+# Install the interpreter with $(VERSION) affixed
+# This goes into $(exec_prefix)
+altbininstall: $(BUILDPYTHON) @FRAMEWORKPYTHONW@
+	@for i in $(BINDIR) $(LIBDIR); \
+	do \
+		if test ! -d $(DESTDIR)$$i; then \
+			echo "Creating directory $$i"; \
+			$(INSTALL) -d -m $(DIRMODE) $(DESTDIR)$$i; \
+		else	true; \
+		fi; \
+	done
+	if test "$(PYTHONFRAMEWORKDIR)" = "no-framework" ; then \
+		$(INSTALL_PROGRAM) $(BUILDPYTHON) $(DESTDIR)$(BINDIR)/python$(LDVERSION)$(EXE); \
+	else \
+		$(INSTALL_PROGRAM) $(STRIPFLAG) Mac/pythonw $(DESTDIR)$(BINDIR)/python$(LDVERSION)$(EXE); \
+	fi
+	-if test "$(VERSION)" != "$(LDVERSION)"; then \
+		if test -f $(DESTDIR)$(BINDIR)/python$(VERSION)$(EXE) -o -h $(DESTDIR)$(BINDIR)/python$(VERSION)$(EXE); \
+		then rm -f $(DESTDIR)$(BINDIR)/python$(VERSION)$(EXE); \
+		fi; \
+		(cd $(DESTDIR)$(BINDIR); $(LN) python$(LDVERSION)$(EXE) python$(VERSION)$(EXE)); \
+	fi
+	if test -f $(LDLIBRARY) && test "$(PYTHONFRAMEWORKDIR)" = "no-framework" ; then \
+		if test -n "$(DLLLIBRARY)" ; then \
+			$(INSTALL_SHARED) $(DLLLIBRARY) $(DESTDIR)$(BINDIR); \
+		else \
+			$(INSTALL_SHARED) $(LDLIBRARY) $(DESTDIR)$(LIBDIR)/$(INSTSONAME); \
+			if test $(LDLIBRARY) != $(INSTSONAME); then \
+				(cd $(DESTDIR)$(LIBDIR); $(LN) -sf $(INSTSONAME) $(LDLIBRARY)) \
+			fi \
+		fi; \
+		if test -n "$(PY3LIBRARY)"; then \
+			$(INSTALL_SHARED) $(PY3LIBRARY) $(DESTDIR)$(LIBDIR)/$(PY3LIBRARY); \
+		fi; \
+	else	true; \
+	fi
+	if test "x$(LIPO_32BIT_FLAGS)" != "x" ; then \
+		rm -f $(DESTDIR)$(BINDIR)python$(VERSION)-32$(EXE); \
+		lipo $(LIPO_32BIT_FLAGS) \
+			-output $(DESTDIR)$(BINDIR)/python$(VERSION)-32$(EXE) \
+			$(DESTDIR)$(BINDIR)/python$(VERSION)$(EXE); \
+	fi
+
+bininstall: altbininstall
+	if test ! -d $(DESTDIR)$(LIBPC); then \
+		echo "Creating directory $(LIBPC)"; \
+		$(INSTALL) -d -m $(DIRMODE) $(DESTDIR)$(LIBPC); \
+	fi
+	-if test -f $(DESTDIR)$(BINDIR)/python3$(EXE) -o -h $(DESTDIR)$(BINDIR)/python3$(EXE); \
+	then rm -f $(DESTDIR)$(BINDIR)/python3$(EXE); \
+	else true; \
+	fi
+	(cd $(DESTDIR)$(BINDIR); $(LN) -s python$(VERSION)$(EXE) python3$(EXE))
+	-if test "$(VERSION)" != "$(LDVERSION)"; then \
+		rm -f $(DESTDIR)$(BINDIR)/python$(VERSION)-config; \
+		(cd $(DESTDIR)$(BINDIR); $(LN) -s python$(LDVERSION)-config python$(VERSION)-config); \
+		rm -f $(DESTDIR)$(LIBPC)/python-$(LDVERSION).pc; \
+		(cd $(DESTDIR)$(LIBPC); $(LN) -s python-$(VERSION).pc python-$(LDVERSION).pc); \
+	fi
+	-rm -f $(DESTDIR)$(BINDIR)/python3-config
+	(cd $(DESTDIR)$(BINDIR); $(LN) -s python$(VERSION)-config python3-config)
+	-rm -f $(DESTDIR)$(LIBPC)/python3.pc
+	(cd $(DESTDIR)$(LIBPC); $(LN) -s python-$(VERSION).pc python3.pc)
+	-rm -f $(DESTDIR)$(BINDIR)/idle3
+	(cd $(DESTDIR)$(BINDIR); $(LN) -s idle$(VERSION) idle3)
+	-rm -f $(DESTDIR)$(BINDIR)/pydoc3
+	(cd $(DESTDIR)$(BINDIR); $(LN) -s pydoc$(VERSION) pydoc3)
+	-rm -f $(DESTDIR)$(BINDIR)/2to3
+	(cd $(DESTDIR)$(BINDIR); $(LN) -s 2to3-$(VERSION) 2to3)
+	-rm -f $(DESTDIR)$(BINDIR)/pyvenv
+	(cd $(DESTDIR)$(BINDIR); $(LN) -s pyvenv-$(VERSION) pyvenv)
+	if test "x$(LIPO_32BIT_FLAGS)" != "x" ; then \
+		rm -f $(DESTDIR)$(BINDIR)/python3-32$(EXE); \
+		(cd $(DESTDIR)$(BINDIR); $(LN) -s python$(VERSION)-32$(EXE) python3-32$(EXE)) \
+	fi
+
+# Install the versioned manual page
+altmaninstall:
+	@for i in $(MANDIR) $(MANDIR)/man1; \
+	do \
+		if test ! -d $(DESTDIR)$$i; then \
+			echo "Creating directory $$i"; \
+			$(INSTALL) -d -m $(DIRMODE) $(DESTDIR)$$i; \
+		else	true; \
+		fi; \
+	done
+	$(INSTALL_DATA) $(srcdir)/Misc/python.man \
+		$(DESTDIR)$(MANDIR)/man1/python$(VERSION).1
+
+# Install the unversioned manual page
+maninstall:	altmaninstall
+	-rm -f $(DESTDIR)$(MANDIR)/man1/python3.1
+	(cd $(DESTDIR)$(MANDIR)/man1; $(LN) -s python$(VERSION).1 python3.1)
+
+# Install the library
+XMLLIBSUBDIRS=  xml xml/dom xml/etree xml/parsers xml/sax
+LIBSUBDIRS=	tkinter tkinter/test tkinter/test/test_tkinter \
+		tkinter/test/test_ttk site-packages test \
+		test/audiodata \
+		test/capath test/data \
+		test/cjkencodings test/decimaltestdata test/xmltestdata \
+		test/dtracedata \
+		test/eintrdata \
+		test/imghdrdata \
+		test/libregrtest \
+		test/subprocessdata test/sndhdrdata test/support \
+		test/tracedmodules test/encoded_modules \
+		test/test_import \
+		test/test_import/data \
+		test/test_import/data/circular_imports \
+		test/test_import/data/circular_imports/subpkg \
+		test/test_import/data/package \
+		test/test_import/data/package2 \
+		importlib \
+		test/test_importlib \
+		test/test_importlib/builtin \
+		test/test_importlib/data01 \
+		test/test_importlib/data01/subdirectory \
+		test/test_importlib/data02 \
+		test/test_importlib/data02/one \
+		test/test_importlib/data02/two \
+		test/test_importlib/data03 \
+		test/test_importlib/data03/namespace \
+		test/test_importlib/data03/namespace/portion1 \
+		test/test_importlib/data03/namespace/portion2 \
+		test/test_importlib/extension \
+		test/test_importlib/frozen \
+		test/test_importlib/import_ \
+		test/test_importlib/namespace_pkgs \
+		test/test_importlib/namespace_pkgs/both_portions \
+		test/test_importlib/namespace_pkgs/both_portions/foo \
+		test/test_importlib/namespace_pkgs/module_and_namespace_package \
+		test/test_importlib/namespace_pkgs/module_and_namespace_package/a_test \
+		test/test_importlib/namespace_pkgs/not_a_namespace_pkg \
+		test/test_importlib/namespace_pkgs/not_a_namespace_pkg/foo \
+		test/test_importlib/namespace_pkgs/portion1 \
+		test/test_importlib/namespace_pkgs/portion1/foo \
+		test/test_importlib/namespace_pkgs/portion2 \
+		test/test_importlib/namespace_pkgs/portion2/foo \
+		test/test_importlib/namespace_pkgs/project1 \
+		test/test_importlib/namespace_pkgs/project1/parent \
+		test/test_importlib/namespace_pkgs/project1/parent/child \
+		test/test_importlib/namespace_pkgs/project2 \
+		test/test_importlib/namespace_pkgs/project2/parent \
+		test/test_importlib/namespace_pkgs/project2/parent/child \
+		test/test_importlib/namespace_pkgs/project3 \
+		test/test_importlib/namespace_pkgs/project3/parent \
+		test/test_importlib/namespace_pkgs/project3/parent/child \
+		test/test_importlib/source \
+		test/test_importlib/zipdata01 \
+		test/test_importlib/zipdata02 \
+		asyncio \
+		test/test_asyncio \
+		collections concurrent concurrent/futures encodings \
+		email email/mime test/test_email test/test_email/data \
+		ensurepip ensurepip/_bundled \
+		html json test/test_json http dbm xmlrpc \
+		sqlite3 sqlite3/test \
+		logging csv wsgiref urllib \
+		lib2to3 lib2to3/fixes lib2to3/pgen2 lib2to3/tests \
+		lib2to3/tests/data lib2to3/tests/data/fixers \
+		lib2to3/tests/data/fixers/myfixes \
+		ctypes ctypes/test ctypes/macholib \
+		idlelib idlelib/Icons idlelib/idle_test \
+		distutils distutils/command distutils/tests $(XMLLIBSUBDIRS) \
+		test/test_tools test/test_warnings test/test_warnings/data \
+		turtledemo \
+		multiprocessing multiprocessing/dummy \
+		unittest unittest/test unittest/test/testmock \
+		venv venv/scripts venv/scripts/common venv/scripts/posix \
+		curses pydoc_data
+libinstall:	build_all $(srcdir)/Modules/xxmodule.c
+	@for i in $(SCRIPTDIR) $(LIBDEST); \
+	do \
+		if test ! -d $(DESTDIR)$$i; then \
+			echo "Creating directory $$i"; \
+			$(INSTALL) -d -m $(DIRMODE) $(DESTDIR)$$i; \
+		else	true; \
+		fi; \
+	done
+	@for d in $(LIBSUBDIRS); \
+	do \
+		a=$(srcdir)/Lib/$$d; \
+		if test ! -d $$a; then continue; else true; fi; \
+		b=$(LIBDEST)/$$d; \
+		if test ! -d $(DESTDIR)$$b; then \
+			echo "Creating directory $$b"; \
+			$(INSTALL) -d -m $(DIRMODE) $(DESTDIR)$$b; \
+		else	true; \
+		fi; \
+	done
+	@for i in $(srcdir)/Lib/*.py; \
+	do \
+		if test -x $$i; then \
+			$(INSTALL_SCRIPT) $$i $(DESTDIR)$(LIBDEST); \
+			echo $(INSTALL_SCRIPT) $$i $(LIBDEST); \
+		else \
+			$(INSTALL_DATA) $$i $(DESTDIR)$(LIBDEST); \
+			echo $(INSTALL_DATA) $$i $(LIBDEST); \
+		fi; \
+	done
+	@for d in $(LIBSUBDIRS); \
+	do \
+		a=$(srcdir)/Lib/$$d; \
+		if test ! -d $$a; then continue; else true; fi; \
+		if test `ls $$a | wc -l` -lt 1; then continue; fi; \
+		b=$(LIBDEST)/$$d; \
+		for i in $$a/*; \
+		do \
+			case $$i in \
+			*CVS) ;; \
+			*.py[co]) ;; \
+			*.orig) ;; \
+			*~) ;; \
+			*) \
+				if test -d $$i; then continue; fi; \
+				if test -x $$i; then \
+				    echo $(INSTALL_SCRIPT) $$i $$b; \
+				    $(INSTALL_SCRIPT) $$i $(DESTDIR)$$b; \
+				else \
+				    echo $(INSTALL_DATA) $$i $$b; \
+				    $(INSTALL_DATA) $$i $(DESTDIR)$$b; \
+				fi;; \
+			esac; \
+		done; \
+	done
+	$(INSTALL_DATA) `cat pybuilddir.txt`/_sysconfigdata_$(ABIFLAGS)_$(MACHDEP)_$(MULTIARCH).py \
+		$(DESTDIR)$(LIBDEST); \
+	$(INSTALL_DATA) $(srcdir)/LICENSE $(DESTDIR)$(LIBDEST)/LICENSE.txt
+	if test -d $(DESTDIR)$(LIBDEST)/distutils/tests; then \
+		$(INSTALL_DATA) $(srcdir)/Modules/xxmodule.c \
+			$(DESTDIR)$(LIBDEST)/distutils/tests ; \
+	fi
+	-PYTHONPATH=$(DESTDIR)$(LIBDEST)  $(RUNSHARED) \
+		$(PYTHON_FOR_BUILD) -Wi $(DESTDIR)$(LIBDEST)/compileall.py \
+		-d $(LIBDEST) -f \
+		-x 'bad_coding|badsyntax|site-packages|lib2to3/tests/data' \
+		$(DESTDIR)$(LIBDEST)
+	-PYTHONPATH=$(DESTDIR)$(LIBDEST) $(RUNSHARED) \
+		$(PYTHON_FOR_BUILD) -Wi -O $(DESTDIR)$(LIBDEST)/compileall.py \
+		-d $(LIBDEST) -f \
+		-x 'bad_coding|badsyntax|site-packages|lib2to3/tests/data' \
+		$(DESTDIR)$(LIBDEST)
+	-PYTHONPATH=$(DESTDIR)$(LIBDEST) $(RUNSHARED) \
+		$(PYTHON_FOR_BUILD) -Wi -OO $(DESTDIR)$(LIBDEST)/compileall.py \
+		-d $(LIBDEST) -f \
+		-x 'bad_coding|badsyntax|site-packages|lib2to3/tests/data' \
+		$(DESTDIR)$(LIBDEST)
+	-PYTHONPATH=$(DESTDIR)$(LIBDEST) $(RUNSHARED) \
+		$(PYTHON_FOR_BUILD) -Wi $(DESTDIR)$(LIBDEST)/compileall.py \
+		-d $(LIBDEST)/site-packages -f \
+		-x badsyntax $(DESTDIR)$(LIBDEST)/site-packages
+	-PYTHONPATH=$(DESTDIR)$(LIBDEST) $(RUNSHARED) \
+		$(PYTHON_FOR_BUILD) -Wi -O $(DESTDIR)$(LIBDEST)/compileall.py \
+		-d $(LIBDEST)/site-packages -f \
+		-x badsyntax $(DESTDIR)$(LIBDEST)/site-packages
+	-PYTHONPATH=$(DESTDIR)$(LIBDEST) $(RUNSHARED) \
+		$(PYTHON_FOR_BUILD) -Wi -OO $(DESTDIR)$(LIBDEST)/compileall.py \
+		-d $(LIBDEST)/site-packages -f \
+		-x badsyntax $(DESTDIR)$(LIBDEST)/site-packages
+	-PYTHONPATH=$(DESTDIR)$(LIBDEST) $(RUNSHARED) \
+		$(PYTHON_FOR_BUILD) -m lib2to3.pgen2.driver $(DESTDIR)$(LIBDEST)/lib2to3/Grammar.txt
+	-PYTHONPATH=$(DESTDIR)$(LIBDEST) $(RUNSHARED) \
+		$(PYTHON_FOR_BUILD) -m lib2to3.pgen2.driver $(DESTDIR)$(LIBDEST)/lib2to3/PatternGrammar.txt
+
+python-config: $(srcdir)/Misc/python-config.in Misc/python-config.sh
+	@ # Substitution happens here, as the completely-expanded BINDIR
+	@ # is not available in configure
+	sed -e "s,@EXENAME@,$(BINDIR)/python$(LDVERSION)$(EXE)," < $(srcdir)/Misc/python-config.in >python-config.py
+	@ # Replace makefile compat. variable references with shell script compat. ones; $(VAR) -> ${VAR}
+	LC_ALL=C sed -e 's,\$$(\([A-Za-z0-9_]*\)),\$$\{\1\},g' < Misc/python-config.sh >python-config
+	@ # On Darwin, always use the python version of the script, the shell
+	@ # version doesn't use the compiler customizations that are provided
+	@ # in python (_osx_support.py).
+	@if test `uname -s` = Darwin; then \
+		cp python-config.py python-config; \
+	fi
+
+
+# Install the include files
+INCLDIRSTOMAKE=$(INCLUDEDIR) $(CONFINCLUDEDIR) $(INCLUDEPY) $(CONFINCLUDEPY)
+inclinstall:
+	@for i in $(INCLDIRSTOMAKE); \
+	do \
+		if test ! -d $(DESTDIR)$$i; then \
+			echo "Creating directory $$i"; \
+			$(INSTALL) -d -m $(DIRMODE) $(DESTDIR)$$i; \
+		else	true; \
+		fi; \
+	done
+	@if test ! -d $(DESTDIR)$(INCLUDEPY)/internal; then \
+		echo "Creating directory $(DESTDIR)$(INCLUDEPY)/internal"; \
+		$(INSTALL) -d -m $(DIRMODE) $(DESTDIR)$(INCLUDEPY)/internal; \
+	else	true; \
+	fi
+	@for i in $(srcdir)/Include/*.h; \
+	do \
+		echo $(INSTALL_DATA) $$i $(INCLUDEPY); \
+		$(INSTALL_DATA) $$i $(DESTDIR)$(INCLUDEPY); \
+	done
+	@for i in $(srcdir)/Include/internal/*.h; \
+	do \
+		echo $(INSTALL_DATA) $$i $(INCLUDEPY)/internal; \
+		$(INSTALL_DATA) $$i $(DESTDIR)$(INCLUDEPY)/internal; \
+	done
+	$(INSTALL_DATA) pyconfig.h $(DESTDIR)$(CONFINCLUDEPY)/pyconfig.h
+
+# Install the library and miscellaneous stuff needed for extending/embedding
+# This goes into $(exec_prefix)
+LIBPL=		@LIBPL@
+
+# pkgconfig directory
+LIBPC=		$(LIBDIR)/$(MULTIARCH)/pkgconfig
+
+libainstall:	@DEF_MAKE_RULE@ python-config
+	@for i in $(LIBDIR) $(LIBPL) $(LIBPC); \
+	do \
+		if test ! -d $(DESTDIR)$$i; then \
+			echo "Creating directory $$i"; \
+			$(INSTALL) -d -m $(DIRMODE) $(DESTDIR)$$i; \
+		else	true; \
+		fi; \
+	done
+	@if test -d $(LIBRARY); then :; else \
+		if test "$(PYTHONFRAMEWORKDIR)" = no-framework; then \
+			if test "$(SHLIB_SUFFIX)" = .dll; then \
+				$(INSTALL_DATA) $(LDLIBRARY) $(DESTDIR)$(LIBPL) ; \
+			else \
+				$(INSTALL_DATA) $(LIBRARY) $(DESTDIR)$(LIBPL)/$(LIBRARY) ; \
+			fi; \
+		else \
+			echo Skip install of $(LIBRARY) - use make frameworkinstall; \
+		fi; \
+	fi
+	$(INSTALL_DATA) Modules/config.c $(DESTDIR)$(LIBPL)/config.c
+	$(INSTALL_DATA) Programs/python.o $(DESTDIR)$(LIBPL)/python.o
+	$(INSTALL_DATA) $(srcdir)/Modules/config.c.in $(DESTDIR)$(LIBPL)/config.c.in
+	$(INSTALL_DATA) Makefile $(DESTDIR)$(LIBPL)/Makefile
+	$(INSTALL_DATA) Modules/Setup $(DESTDIR)$(LIBPL)/Setup
+	$(INSTALL_DATA) Modules/Setup.local $(DESTDIR)$(LIBPL)/Setup.local
+	$(INSTALL_DATA) Misc/python.pc $(DESTDIR)$(LIBPC)/python-$(VERSION).pc
+	$(INSTALL_SCRIPT) $(srcdir)/Modules/makesetup $(DESTDIR)$(LIBPL)/makesetup
+	$(INSTALL_SCRIPT) $(srcdir)/install-sh $(DESTDIR)$(LIBPL)/install-sh
+	$(INSTALL_SCRIPT) python-config.py $(DESTDIR)$(LIBPL)/python-config.py
+	$(INSTALL_SCRIPT) python-config $(DESTDIR)$(BINDIR)/python$(LDVERSION)-config
+	@if [ -s Modules/python.exp -a \
+		"`echo $(MACHDEP) | sed 's/^\(...\).*/\1/'`" = "aix" ]; then \
+		echo; echo "Installing support files for building shared extension modules on AIX:"; \
+		$(INSTALL_DATA) Modules/python.exp		\
+				$(DESTDIR)$(LIBPL)/python.exp;		\
+		echo; echo "$(LIBPL)/python.exp";		\
+		$(INSTALL_SCRIPT) $(srcdir)/Modules/makexp_aix	\
+				$(DESTDIR)$(LIBPL)/makexp_aix;		\
+		echo "$(LIBPL)/makexp_aix";			\
+		$(INSTALL_SCRIPT) Modules/ld_so_aix	\
+				$(DESTDIR)$(LIBPL)/ld_so_aix;		\
+		echo "$(LIBPL)/ld_so_aix";			\
+		echo; echo "See Misc/AIX-NOTES for details.";	\
+	else true; \
+	fi
+
+# Install the dynamically loadable modules
+# This goes into $(exec_prefix)
+sharedinstall: sharedmods
+	$(RUNSHARED) $(PYTHON_FOR_BUILD) $(srcdir)/setup.py install \
+	   	--prefix=$(prefix) \
+		--install-scripts=$(BINDIR) \
+		--install-platlib=$(DESTSHARED) \
+		--root=$(DESTDIR)/
+	-rm $(DESTDIR)$(DESTSHARED)/_sysconfigdata_$(ABIFLAGS)_$(MACHDEP)_$(MULTIARCH).py
+	-rm -r $(DESTDIR)$(DESTSHARED)/__pycache__
+
+# Here are a couple of targets for MacOSX again, to install a full
+# framework-based Python. frameworkinstall installs everything, the
+# subtargets install specific parts. Much of the actual work is offloaded to
+# the Makefile in Mac
+#
+#
+# This target is here for backward compatibility, previous versions of Python
+# hadn't integrated framework installation in the normal install process.
+frameworkinstall: install
+
+# On install, we re-make the framework
+# structure in the install location, /Library/Frameworks/ or the argument to
+# --enable-framework. If --enable-framework has been specified then we have
+# automatically set prefix to the location deep down in the framework, so we
+# only have to cater for the structural bits of the framework.
+
+frameworkinstallframework: frameworkinstallstructure install frameworkinstallmaclib
+
+frameworkinstallstructure:	$(LDLIBRARY)
+	@if test "$(PYTHONFRAMEWORKDIR)" = no-framework; then \
+		echo Not configured with --enable-framework; \
+		exit 1; \
+	else true; \
+	fi
+	@for i in $(prefix)/Resources/English.lproj $(prefix)/lib; do\
+		if test ! -d $(DESTDIR)$$i; then \
+			echo "Creating directory $(DESTDIR)$$i"; \
+			$(INSTALL) -d -m $(DIRMODE) $(DESTDIR)$$i; \
+		else	true; \
+		fi; \
+	done
+	$(LN) -fsn include/python$(LDVERSION) $(DESTDIR)$(prefix)/Headers
+	sed 's/%VERSION%/'"`$(RUNSHARED) ./$(BUILDPYTHON) -c 'import platform; print(platform.python_version())'`"'/g' < $(RESSRCDIR)/Info.plist > $(DESTDIR)$(prefix)/Resources/Info.plist
+	$(LN) -fsn $(VERSION) $(DESTDIR)$(PYTHONFRAMEWORKINSTALLDIR)/Versions/Current
+	$(LN) -fsn Versions/Current/$(PYTHONFRAMEWORK) $(DESTDIR)$(PYTHONFRAMEWORKINSTALLDIR)/$(PYTHONFRAMEWORK)
+	$(LN) -fsn Versions/Current/Headers $(DESTDIR)$(PYTHONFRAMEWORKINSTALLDIR)/Headers
+	$(LN) -fsn Versions/Current/Resources $(DESTDIR)$(PYTHONFRAMEWORKINSTALLDIR)/Resources
+	$(INSTALL_SHARED) $(LDLIBRARY) $(DESTDIR)$(PYTHONFRAMEWORKPREFIX)/$(LDLIBRARY)
+
+# This installs Mac/Lib into the framework
+# Install a number of symlinks to keep software that expects a normal unix
+# install (which includes python-config) happy.
+frameworkinstallmaclib:
+	$(LN) -fs "../../../$(PYTHONFRAMEWORK)" "$(DESTDIR)$(LIBPL)/libpython$(LDVERSION).a"
+	$(LN) -fs "../../../$(PYTHONFRAMEWORK)" "$(DESTDIR)$(LIBPL)/libpython$(LDVERSION).dylib"
+	$(LN) -fs "../../../$(PYTHONFRAMEWORK)" "$(DESTDIR)$(LIBPL)/libpython$(VERSION).a"
+	$(LN) -fs "../../../$(PYTHONFRAMEWORK)" "$(DESTDIR)$(LIBPL)/libpython$(VERSION).dylib"
+	$(LN) -fs "../$(PYTHONFRAMEWORK)" "$(DESTDIR)$(prefix)/lib/libpython$(LDVERSION).dylib"
+	$(LN) -fs "../$(PYTHONFRAMEWORK)" "$(DESTDIR)$(prefix)/lib/libpython$(VERSION).dylib"
+
+# This installs the IDE, the Launcher and other apps into /Applications
+frameworkinstallapps:
+	cd Mac && $(MAKE) installapps DESTDIR="$(DESTDIR)"
+
+# Build the bootstrap executable that will spawn the interpreter inside
+# an app bundle within the framework.  This allows the interpreter to
+# run OS X GUI APIs.
+frameworkpythonw:
+	cd Mac && $(MAKE) pythonw
+
+# This installs the python* and other bin symlinks in $prefix/bin or in
+# a bin directory relative to the framework root
+frameworkinstallunixtools:
+	cd Mac && $(MAKE) installunixtools DESTDIR="$(DESTDIR)"
+
+frameworkaltinstallunixtools:
+	cd Mac && $(MAKE) altinstallunixtools DESTDIR="$(DESTDIR)"
+
+# This installs the Tools into the applications directory.
+# It is not part of a normal frameworkinstall
+frameworkinstallextras:
+	cd Mac && $(MAKE) installextras DESTDIR="$(DESTDIR)"
+
+# This installs a few of the useful scripts in Tools/scripts
+scriptsinstall:
+	SRCDIR=$(srcdir) $(RUNSHARED) \
+	$(PYTHON_FOR_BUILD) $(srcdir)/Tools/scripts/setup.py install \
+	--prefix=$(prefix) \
+	--install-scripts=$(BINDIR) \
+	--root=$(DESTDIR)/
+
+# Build the toplevel Makefile
+Makefile.pre: $(srcdir)/Makefile.pre.in config.status
+	CONFIG_FILES=Makefile.pre CONFIG_HEADERS= $(SHELL) config.status
+	$(MAKE) -f Makefile.pre Makefile
+
+# Run the configure script.
+config.status:	$(srcdir)/configure
+	$(SHELL) $(srcdir)/configure $(CONFIG_ARGS)
+
+.PRECIOUS: config.status $(BUILDPYTHON) Makefile Makefile.pre
+
+# Some make's put the object file in the current directory
+.c.o:
+	$(CC) -c $(PY_CORE_CFLAGS) -o $@ $<
+
+# bpo-30104: dtoa.c uses union to cast double to unsigned long[2]. clang 4.0
+# with -O2 or higher and strict aliasing miscompiles the ratio() function
+# causing rounding issues. Compile dtoa.c using -fno-strict-aliasing on clang.
+# https://bugs.llvm.org//show_bug.cgi?id=31928
+Python/dtoa.o: Python/dtoa.c
+	$(CC) -c $(PY_CORE_CFLAGS) $(CFLAGS_ALIASING) -o $@ $<
+
+# Run reindent on the library
+reindent:
+	./$(BUILDPYTHON) $(srcdir)/Tools/scripts/reindent.py -r $(srcdir)/Lib
+
+# Rerun configure with the same options as it was run last time,
+# provided the config.status script exists
+recheck:
+	$(SHELL) config.status --recheck
+	$(SHELL) config.status
+
+# Regenerate configure and pyconfig.h.in
+.PHONY: autoconf
+autoconf:
+	# Regenerate the configure script from configure.ac using autoconf
+	(cd $(srcdir); autoconf -Wall)
+	# Regenerate pyconfig.h.in from configure.ac using autoheader
+	(cd $(srcdir); autoheader -Wall)
+
+# Create a tags file for vi
+tags::
+	ctags -w $(srcdir)/Include/*.h $(srcdir)/Include/internal/*.h
+	for i in $(SRCDIRS); do ctags -f tags -w -a $(srcdir)/$$i/*.[ch]; done
+	ctags -f tags -w -a $(srcdir)/Modules/_ctypes/*.[ch]
+	LC_ALL=C sort -o tags tags
+
+# Create a tags file for GNU Emacs
+TAGS::
+	cd $(srcdir); \
+	etags Include/*.h Include/internal/*.h; \
+	for i in $(SRCDIRS); do etags -a $$i/*.[ch]; done
+
+# Sanitation targets -- clean leaves libraries, executables and tags
+# files, which clobber removes as well
+pycremoval:
+	-find $(srcdir) -depth -name '__pycache__' -exec rm -rf {} ';'
+	-find $(srcdir) -name '*.py[co]' -exec rm -f {} ';'
+
+rmtestturds:
+	-rm -f *BAD *GOOD *SKIPPED
+	-rm -rf OUT
+	-rm -f *.TXT
+	-rm -f *.txt
+	-rm -f gb-18030-2000.xml
+
+docclean:
+	-rm -rf Doc/build
+	-rm -rf Doc/tools/sphinx Doc/tools/pygments Doc/tools/docutils
+
+clean: pycremoval
+	find . -name '*.[oa]' -exec rm -f {} ';'
+	find . -name '*.s[ol]' -exec rm -f {} ';'
+	find . -name '*.so.[0-9]*.[0-9]*' -exec rm -f {} ';'
+	find build -name 'fficonfig.h' -exec rm -f {} ';' || true
+	find build -name '*.py' -exec rm -f {} ';' || true
+	find build -name '*.py[co]' -exec rm -f {} ';' || true
+	-rm -f pybuilddir.txt
+	-rm -f Lib/lib2to3/*Grammar*.pickle
+	-rm -f Programs/_testembed Programs/_freeze_importlib
+	-find build -type f -a ! -name '*.gc??' -exec rm -f {} ';'
+	-rm -f Include/pydtrace_probes.h
+	-rm -f profile-gen-stamp
+
+profile-removal:
+	find . -name '*.gc??' -exec rm -f {} ';'
+	find . -name '*.profclang?' -exec rm -f {} ';'
+	find . -name '*.dyn' -exec rm -f {} ';'
+	rm -f $(COVERAGE_INFO)
+	rm -rf $(COVERAGE_REPORT)
+	rm -f profile-run-stamp
+
+clobber: clean profile-removal
+	-rm -f $(BUILDPYTHON) $(PGEN) $(LIBRARY) $(LDLIBRARY) $(DLLLIBRARY) \
+		tags TAGS \
+		config.cache config.log pyconfig.h Modules/config.c
+	-rm -rf build platform
+	-rm -rf $(PYTHONFRAMEWORKDIR)
+	-rm -f python-config.py python-config
+	-rm -f profile-gen-stamp profile-clean-stamp
+
+# Make things extra clean, before making a distribution:
+# remove all generated files, even Makefile[.pre]
+# Keep configure and Python-ast.[ch], it's possible they can't be generated
+distclean: clobber
+	for file in $(srcdir)/Lib/test/data/* ; do \
+	    if test "$$file" != "$(srcdir)/Lib/test/data/README"; then rm "$$file"; fi; \
+	done
+	-rm -f core Makefile Makefile.pre config.status \
+		Modules/Setup Modules/Setup.local \
+		Modules/ld_so_aix Modules/python.exp Misc/python.pc \
+		Misc/python-config.sh
+	-rm -f python*-gdb.py
+	# Issue #28258: set LC_ALL to avoid issues with Estonian locale.
+	# Expansion is performed here by shell (spawned by make) itself before
+	# arguments are passed to find. So LC_ALL=C must be set as a separate
+	# command.
+	LC_ALL=C; find $(srcdir)/[a-zA-Z]* '(' -name '*.fdc' -o -name '*~' \
+				     -o -name '[@,#]*' -o -name '*.old' \
+				     -o -name '*.orig' -o -name '*.rej' \
+				     -o -name '*.bak' ')' \
+				     -exec rm -f {} ';'
+
+# Check that all symbols exported by libpython start with "Py" or "_Py"
+smelly: @DEF_MAKE_RULE@
+	$(RUNSHARED) ./$(BUILDPYTHON) Tools/scripts/smelly.py
+
+# Find files with funny names
+funny:
+	find $(SUBDIRS) $(SUBDIRSTOO) \
+		-type d \
+		-o -name '*.[chs]' \
+		-o -name '*.py' \
+		-o -name '*.pyw' \
+		-o -name '*.dat' \
+		-o -name '*.el' \
+		-o -name '*.fd' \
+		-o -name '*.in' \
+		-o -name '*.gif' \
+		-o -name '*.txt' \
+		-o -name '*.xml' \
+		-o -name '*.xbm' \
+		-o -name '*.xpm' \
+		-o -name '*.uue' \
+		-o -name '*.decTest' \
+		-o -name '*.tmCommand' \
+		-o -name '*.tmSnippet' \
+		-o -name 'Setup' \
+		-o -name 'Setup.*' \
+		-o -name README \
+		-o -name NEWS \
+		-o -name HISTORY \
+		-o -name Makefile \
+		-o -name ChangeLog \
+		-o -name .hgignore \
+		-o -name MANIFEST \
+		-o -print
+
+# Perform some verification checks on any modified files.
+patchcheck: @DEF_MAKE_RULE@
+	$(RUNSHARED) ./$(BUILDPYTHON) $(srcdir)/Tools/scripts/patchcheck.py
+
+# Dependencies
+
+Python/thread.o: @THREADHEADERS@
+
+# Declare targets that aren't real files
+.PHONY: all build_all sharedmods check-clean-src oldsharedmods test quicktest
+.PHONY: install altinstall oldsharedinstall bininstall altbininstall
+.PHONY: maninstall libinstall inclinstall libainstall sharedinstall
+.PHONY: frameworkinstall frameworkinstallframework frameworkinstallstructure
+.PHONY: frameworkinstallmaclib frameworkinstallapps frameworkinstallunixtools
+.PHONY: frameworkaltinstallunixtools recheck clean clobber distclean
+.PHONY: smelly funny patchcheck touch altmaninstall commoninstall
+.PHONY: gdbhooks
+
+# IF YOU PUT ANYTHING HERE IT WILL GO AWAY
+# Local Variables:
+# mode: makefile
+# End:
diff --git a/Modules/getpath.c b/Modules/getpath.c
index bfb3331..e78e3d2 100644
--- a/Modules/getpath.c
+++ b/Modules/getpath.c
@@ -123,6 +123,7 @@ typedef struct {
     wchar_t *exec_prefix;              /* EXEC_PREFIX define */
 
     wchar_t *lib_python;               /* "lib/pythonX.Y" */
+    wchar_t *multilib_python;               /* "lib[suffix]/pythonX.Y" */
     wchar_t argv0_path[MAXPATHLEN+1];
     wchar_t zip_path[MAXPATHLEN+1];    /* ".../lib/pythonXY.zip" */
 
@@ -349,7 +350,7 @@ search_for_prefix(const _PyCoreConfig *core_config,
         if (delim) {
             *delim = L'\0';
         }
-        joinpath(prefix, calculate->lib_python);
+        joinpath(prefix, calculate->multilib_python);
         joinpath(prefix, LANDMARK);
         return 1;
     }
@@ -378,7 +379,7 @@ search_for_prefix(const _PyCoreConfig *core_config,
     copy_absolute(prefix, calculate->argv0_path, MAXPATHLEN+1);
     do {
         n = wcslen(prefix);
-        joinpath(prefix, calculate->lib_python);
+        joinpath(prefix, calculate->multilib_python);
         joinpath(prefix, LANDMARK);
         if (ismodule(prefix)) {
             return 1;
@@ -390,7 +391,7 @@ search_for_prefix(const _PyCoreConfig *core_config,
     /* Look at configure's PREFIX */
     wcsncpy(prefix, calculate->prefix, MAXPATHLEN);
     prefix[MAXPATHLEN] = L'\0';
-    joinpath(prefix, calculate->lib_python);
+    joinpath(prefix, calculate->multilib_python);
     joinpath(prefix, LANDMARK);
     if (ismodule(prefix)) {
         return 1;
@@ -462,7 +463,7 @@ search_for_exec_prefix(const _PyCoreConfig *core_config,
             wcsncpy(exec_prefix, core_config->home, MAXPATHLEN);
         }
         exec_prefix[MAXPATHLEN] = L'\0';
-        joinpath(exec_prefix, calculate->lib_python);
+        joinpath(exec_prefix, calculate->multilib_python);
         joinpath(exec_prefix, L"lib-dynload");
         return 1;
     }
@@ -499,7 +500,7 @@ search_for_exec_prefix(const _PyCoreConfig *core_config,
     copy_absolute(exec_prefix, calculate->argv0_path, MAXPATHLEN+1);
     do {
         n = wcslen(exec_prefix);
-        joinpath(exec_prefix, calculate->lib_python);
+        joinpath(exec_prefix, calculate->multilib_python);
         joinpath(exec_prefix, L"lib-dynload");
         if (isdir(exec_prefix)) {
             return 1;
@@ -511,7 +512,7 @@ search_for_exec_prefix(const _PyCoreConfig *core_config,
     /* Look at configure's EXEC_PREFIX */
     wcsncpy(exec_prefix, calculate->exec_prefix, MAXPATHLEN);
     exec_prefix[MAXPATHLEN] = L'\0';
-    joinpath(exec_prefix, calculate->lib_python);
+    joinpath(exec_prefix, calculate->multilib_python);
     joinpath(exec_prefix, L"lib-dynload");
     if (isdir(exec_prefix)) {
         return 1;
@@ -916,6 +917,10 @@ calculate_init(PyCalculatePath *calculate,
     if (!calculate->lib_python) {
         return DECODE_LOCALE_ERR("EXEC_PREFIX define", len);
     }
+    calculate->multilib_python = Py_DecodeLocale(LIB "/python" VERSION, &len);
+    if (!calculate->multilib_python) {
+        return DECODE_LOCALE_ERR("EXEC_PREFIX define", len);
+    }
     return _Py_INIT_OK();
 }
 
@@ -927,6 +932,7 @@ calculate_free(PyCalculatePath *calculate)
     PyMem_RawFree(calculate->prefix);
     PyMem_RawFree(calculate->exec_prefix);
     PyMem_RawFree(calculate->lib_python);
+    PyMem_RawFree(calculate->multilib_python);
     PyMem_RawFree(calculate->path_env);
 }
 
diff --git a/Modules/getpath.c.orig b/Modules/getpath.c.orig
new file mode 100644
index 0000000..bfb3331
--- /dev/null
+++ b/Modules/getpath.c.orig
@@ -0,0 +1,1018 @@
+/* Return the initial module search path. */
+
+#include "Python.h"
+#include "internal/pystate.h"
+#include "osdefs.h"
+
+#include <sys/types.h>
+#include <string.h>
+
+#ifdef __APPLE__
+#  include <mach-o/dyld.h>
+#endif
+
+/* Search in some common locations for the associated Python libraries.
+ *
+ * Two directories must be found, the platform independent directory
+ * (prefix), containing the common .py and .pyc files, and the platform
+ * dependent directory (exec_prefix), containing the shared library
+ * modules.  Note that prefix and exec_prefix can be the same directory,
+ * but for some installations, they are different.
+ *
+ * Py_GetPath() carries out separate searches for prefix and exec_prefix.
+ * Each search tries a number of different locations until a ``landmark''
+ * file or directory is found.  If no prefix or exec_prefix is found, a
+ * warning message is issued and the preprocessor defined PREFIX and
+ * EXEC_PREFIX are used (even though they will not work); python carries on
+ * as best as is possible, but most imports will fail.
+ *
+ * Before any searches are done, the location of the executable is
+ * determined.  If argv[0] has one or more slashes in it, it is used
+ * unchanged.  Otherwise, it must have been invoked from the shell's path,
+ * so we search $PATH for the named executable and use that.  If the
+ * executable was not found on $PATH (or there was no $PATH environment
+ * variable), the original argv[0] string is used.
+ *
+ * Next, the executable location is examined to see if it is a symbolic
+ * link.  If so, the link is chased (correctly interpreting a relative
+ * pathname if one is found) and the directory of the link target is used.
+ *
+ * Finally, argv0_path is set to the directory containing the executable
+ * (i.e. the last component is stripped).
+ *
+ * With argv0_path in hand, we perform a number of steps.  The same steps
+ * are performed for prefix and for exec_prefix, but with a different
+ * landmark.
+ *
+ * Step 1. Are we running python out of the build directory?  This is
+ * checked by looking for a different kind of landmark relative to
+ * argv0_path.  For prefix, the landmark's path is derived from the VPATH
+ * preprocessor variable (taking into account that its value is almost, but
+ * not quite, what we need).  For exec_prefix, the landmark is
+ * pybuilddir.txt.  If the landmark is found, we're done.
+ *
+ * For the remaining steps, the prefix landmark will always be
+ * lib/python$VERSION/os.py and the exec_prefix will always be
+ * lib/python$VERSION/lib-dynload, where $VERSION is Python's version
+ * number as supplied by the Makefile.  Note that this means that no more
+ * build directory checking is performed; if the first step did not find
+ * the landmarks, the assumption is that python is running from an
+ * installed setup.
+ *
+ * Step 2. See if the $PYTHONHOME environment variable points to the
+ * installed location of the Python libraries.  If $PYTHONHOME is set, then
+ * it points to prefix and exec_prefix.  $PYTHONHOME can be a single
+ * directory, which is used for both, or the prefix and exec_prefix
+ * directories separated by a colon.
+ *
+ * Step 3. Try to find prefix and exec_prefix relative to argv0_path,
+ * backtracking up the path until it is exhausted.  This is the most common
+ * step to succeed.  Note that if prefix and exec_prefix are different,
+ * exec_prefix is more likely to be found; however if exec_prefix is a
+ * subdirectory of prefix, both will be found.
+ *
+ * Step 4. Search the directories pointed to by the preprocessor variables
+ * PREFIX and EXEC_PREFIX.  These are supplied by the Makefile but can be
+ * passed in as options to the configure script.
+ *
+ * That's it!
+ *
+ * Well, almost.  Once we have determined prefix and exec_prefix, the
+ * preprocessor variable PYTHONPATH is used to construct a path.  Each
+ * relative path on PYTHONPATH is prefixed with prefix.  Then the directory
+ * containing the shared library modules is appended.  The environment
+ * variable $PYTHONPATH is inserted in front of it all.  Finally, the
+ * prefix and exec_prefix globals are tweaked so they reflect the values
+ * expected by other code, by stripping the "lib/python$VERSION/..." stuff
+ * off.  If either points to the build directory, the globals are reset to
+ * the corresponding preprocessor variables (so sys.prefix will reflect the
+ * installation location, even though sys.path points into the build
+ * directory).  This seems to make more sense given that currently the only
+ * known use of sys.prefix and sys.exec_prefix is for the ILU installation
+ * process to find the installed Python tree.
+ *
+ * An embedding application can use Py_SetPath() to override all of
+ * these authomatic path computations.
+ *
+ * NOTE: Windows MSVC builds use PC/getpathp.c instead!
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#if !defined(PREFIX) || !defined(EXEC_PREFIX) || !defined(VERSION) || !defined(VPATH)
+#error "PREFIX, EXEC_PREFIX, VERSION, and VPATH must be constant defined"
+#endif
+
+#ifndef LANDMARK
+#define LANDMARK L"os.py"
+#endif
+
+#define DECODE_LOCALE_ERR(NAME, LEN) \
+    ((LEN) == (size_t)-2) \
+     ? _Py_INIT_USER_ERR("cannot decode " NAME) \
+     : _Py_INIT_NO_MEMORY()
+
+typedef struct {
+    wchar_t *path_env;                 /* PATH environment variable */
+
+    wchar_t *pythonpath;               /* PYTHONPATH define */
+    wchar_t *prefix;                   /* PREFIX define */
+    wchar_t *exec_prefix;              /* EXEC_PREFIX define */
+
+    wchar_t *lib_python;               /* "lib/pythonX.Y" */
+    wchar_t argv0_path[MAXPATHLEN+1];
+    wchar_t zip_path[MAXPATHLEN+1];    /* ".../lib/pythonXY.zip" */
+
+    int prefix_found;         /* found platform independent libraries? */
+    int exec_prefix_found;    /* found the platform dependent libraries? */
+} PyCalculatePath;
+
+static const wchar_t delimiter[2] = {DELIM, '\0'};
+static const wchar_t separator[2] = {SEP, '\0'};
+
+
+/* Get file status. Encode the path to the locale encoding. */
+static int
+_Py_wstat(const wchar_t* path, struct stat *buf)
+{
+    int err;
+    char *fname;
+    fname = _Py_EncodeLocaleRaw(path, NULL);
+    if (fname == NULL) {
+        errno = EINVAL;
+        return -1;
+    }
+    err = stat(fname, buf);
+    PyMem_RawFree(fname);
+    return err;
+}
+
+
+static void
+reduce(wchar_t *dir)
+{
+    size_t i = wcslen(dir);
+    while (i > 0 && dir[i] != SEP)
+        --i;
+    dir[i] = '\0';
+}
+
+
+static int
+isfile(wchar_t *filename)          /* Is file, not directory */
+{
+    struct stat buf;
+    if (_Py_wstat(filename, &buf) != 0) {
+        return 0;
+    }
+    if (!S_ISREG(buf.st_mode)) {
+        return 0;
+    }
+    return 1;
+}
+
+
+static int
+ismodule(wchar_t *filename)        /* Is module -- check for .pyc too */
+{
+    if (isfile(filename)) {
+        return 1;
+    }
+
+    /* Check for the compiled version of prefix. */
+    if (wcslen(filename) < MAXPATHLEN) {
+        wcscat(filename, L"c");
+        if (isfile(filename)) {
+            return 1;
+        }
+    }
+    return 0;
+}
+
+
+/* Is executable file */
+static int
+isxfile(wchar_t *filename)
+{
+    struct stat buf;
+    if (_Py_wstat(filename, &buf) != 0) {
+        return 0;
+    }
+    if (!S_ISREG(buf.st_mode)) {
+        return 0;
+    }
+    if ((buf.st_mode & 0111) == 0) {
+        return 0;
+    }
+    return 1;
+}
+
+
+/* Is directory */
+static int
+isdir(wchar_t *filename)
+{
+    struct stat buf;
+    if (_Py_wstat(filename, &buf) != 0) {
+        return 0;
+    }
+    if (!S_ISDIR(buf.st_mode)) {
+        return 0;
+    }
+    return 1;
+}
+
+
+/* Add a path component, by appending stuff to buffer.
+   buffer must have at least MAXPATHLEN + 1 bytes allocated, and contain a
+   NUL-terminated string with no more than MAXPATHLEN characters (not counting
+   the trailing NUL).  It's a fatal error if it contains a string longer than
+   that (callers must be careful!).  If these requirements are met, it's
+   guaranteed that buffer will still be a NUL-terminated string with no more
+   than MAXPATHLEN characters at exit.  If stuff is too long, only as much of
+   stuff as fits will be appended.
+*/
+static void
+joinpath(wchar_t *buffer, wchar_t *stuff)
+{
+    size_t n, k;
+    if (stuff[0] == SEP) {
+        n = 0;
+    }
+    else {
+        n = wcslen(buffer);
+        if (n > 0 && buffer[n-1] != SEP && n < MAXPATHLEN) {
+            buffer[n++] = SEP;
+        }
+    }
+    if (n > MAXPATHLEN) {
+        Py_FatalError("buffer overflow in getpath.c's joinpath()");
+    }
+    k = wcslen(stuff);
+    if (n + k > MAXPATHLEN) {
+        k = MAXPATHLEN - n;
+    }
+    wcsncpy(buffer+n, stuff, k);
+    buffer[n+k] = '\0';
+}
+
+
+/* copy_absolute requires that path be allocated at least
+   MAXPATHLEN + 1 bytes and that p be no more than MAXPATHLEN bytes. */
+static void
+copy_absolute(wchar_t *path, wchar_t *p, size_t pathlen)
+{
+    if (p[0] == SEP) {
+        wcscpy(path, p);
+    }
+    else {
+        if (!_Py_wgetcwd(path, pathlen)) {
+            /* unable to get the current directory */
+            wcscpy(path, p);
+            return;
+        }
+        if (p[0] == '.' && p[1] == SEP) {
+            p += 2;
+        }
+        joinpath(path, p);
+    }
+}
+
+
+/* absolutize() requires that path be allocated at least MAXPATHLEN+1 bytes. */
+static void
+absolutize(wchar_t *path)
+{
+    wchar_t buffer[MAXPATHLEN+1];
+
+    if (path[0] == SEP) {
+        return;
+    }
+    copy_absolute(buffer, path, MAXPATHLEN+1);
+    wcscpy(path, buffer);
+}
+
+
+#if defined(__CYGWIN__) || defined(__MINGW32__)
+/* add_exe_suffix requires that progpath be allocated at least
+   MAXPATHLEN + 1 bytes.
+*/
+
+#ifndef EXE_SUFFIX
+#define EXE_SUFFIX L".exe"
+#endif
+
+static void
+add_exe_suffix(wchar_t *progpath)
+{
+    /* Check for already have an executable suffix */
+    size_t n = wcslen(progpath);
+    size_t s = wcslen(EXE_SUFFIX);
+    if (wcsncasecmp(EXE_SUFFIX, progpath+n-s, s) != 0) {
+        if (n + s > MAXPATHLEN) {
+            Py_FatalError("progpath overflow in getpath.c's add_exe_suffix()");
+        }
+        /* Save original path for revert */
+        wchar_t orig[MAXPATHLEN+1];
+        wcsncpy(orig, progpath, MAXPATHLEN);
+
+        wcsncpy(progpath+n, EXE_SUFFIX, s);
+        progpath[n+s] = '\0';
+
+        if (!isxfile(progpath)) {
+            /* Path that added suffix is invalid */
+            wcsncpy(progpath, orig, MAXPATHLEN);
+        }
+    }
+}
+#endif
+
+
+/* search_for_prefix requires that argv0_path be no more than MAXPATHLEN
+   bytes long.
+*/
+static int
+search_for_prefix(const _PyCoreConfig *core_config,
+                  PyCalculatePath *calculate, wchar_t *prefix)
+{
+    size_t n;
+    wchar_t *vpath;
+
+    /* If PYTHONHOME is set, we believe it unconditionally */
+    if (core_config->home) {
+        wcsncpy(prefix, core_config->home, MAXPATHLEN);
+        prefix[MAXPATHLEN] = L'\0';
+        wchar_t *delim = wcschr(prefix, DELIM);
+        if (delim) {
+            *delim = L'\0';
+        }
+        joinpath(prefix, calculate->lib_python);
+        joinpath(prefix, LANDMARK);
+        return 1;
+    }
+
+    /* Check to see if argv[0] is in the build directory */
+    wcsncpy(prefix, calculate->argv0_path, MAXPATHLEN);
+    prefix[MAXPATHLEN] = L'\0';
+    joinpath(prefix, L"Modules/Setup");
+    if (isfile(prefix)) {
+        /* Check VPATH to see if argv0_path is in the build directory. */
+        vpath = Py_DecodeLocale(VPATH, NULL);
+        if (vpath != NULL) {
+            wcsncpy(prefix, calculate->argv0_path, MAXPATHLEN);
+            prefix[MAXPATHLEN] = L'\0';
+            joinpath(prefix, vpath);
+            PyMem_RawFree(vpath);
+            joinpath(prefix, L"Lib");
+            joinpath(prefix, LANDMARK);
+            if (ismodule(prefix)) {
+                return -1;
+            }
+        }
+    }
+
+    /* Search from argv0_path, until root is found */
+    copy_absolute(prefix, calculate->argv0_path, MAXPATHLEN+1);
+    do {
+        n = wcslen(prefix);
+        joinpath(prefix, calculate->lib_python);
+        joinpath(prefix, LANDMARK);
+        if (ismodule(prefix)) {
+            return 1;
+        }
+        prefix[n] = L'\0';
+        reduce(prefix);
+    } while (prefix[0]);
+
+    /* Look at configure's PREFIX */
+    wcsncpy(prefix, calculate->prefix, MAXPATHLEN);
+    prefix[MAXPATHLEN] = L'\0';
+    joinpath(prefix, calculate->lib_python);
+    joinpath(prefix, LANDMARK);
+    if (ismodule(prefix)) {
+        return 1;
+    }
+
+    /* Fail */
+    return 0;
+}
+
+
+static void
+calculate_prefix(const _PyCoreConfig *core_config,
+                 PyCalculatePath *calculate, wchar_t *prefix)
+{
+    calculate->prefix_found = search_for_prefix(core_config, calculate, prefix);
+    if (!calculate->prefix_found) {
+        if (!Py_FrozenFlag) {
+            fprintf(stderr,
+                "Could not find platform independent libraries <prefix>\n");
+        }
+        wcsncpy(prefix, calculate->prefix, MAXPATHLEN);
+        joinpath(prefix, calculate->lib_python);
+    }
+    else {
+        reduce(prefix);
+    }
+}
+
+
+static void
+calculate_reduce_prefix(PyCalculatePath *calculate, wchar_t *prefix)
+{
+    /* Reduce prefix and exec_prefix to their essence,
+     * e.g. /usr/local/lib/python1.5 is reduced to /usr/local.
+     * If we're loading relative to the build directory,
+     * return the compiled-in defaults instead.
+     */
+    if (calculate->prefix_found > 0) {
+        reduce(prefix);
+        reduce(prefix);
+        /* The prefix is the root directory, but reduce() chopped
+         * off the "/". */
+        if (!prefix[0]) {
+            wcscpy(prefix, separator);
+        }
+    }
+    else {
+        wcsncpy(prefix, calculate->prefix, MAXPATHLEN);
+    }
+}
+
+
+/* search_for_exec_prefix requires that argv0_path be no more than
+   MAXPATHLEN bytes long.
+*/
+static int
+search_for_exec_prefix(const _PyCoreConfig *core_config,
+                       PyCalculatePath *calculate, wchar_t *exec_prefix)
+{
+    size_t n;
+
+    /* If PYTHONHOME is set, we believe it unconditionally */
+    if (core_config->home) {
+        wchar_t *delim = wcschr(core_config->home, DELIM);
+        if (delim) {
+            wcsncpy(exec_prefix, delim+1, MAXPATHLEN);
+        }
+        else {
+            wcsncpy(exec_prefix, core_config->home, MAXPATHLEN);
+        }
+        exec_prefix[MAXPATHLEN] = L'\0';
+        joinpath(exec_prefix, calculate->lib_python);
+        joinpath(exec_prefix, L"lib-dynload");
+        return 1;
+    }
+
+    /* Check to see if argv[0] is in the build directory. "pybuilddir.txt"
+       is written by setup.py and contains the relative path to the location
+       of shared library modules. */
+    wcsncpy(exec_prefix, calculate->argv0_path, MAXPATHLEN);
+    exec_prefix[MAXPATHLEN] = L'\0';
+    joinpath(exec_prefix, L"pybuilddir.txt");
+    if (isfile(exec_prefix)) {
+        FILE *f = _Py_wfopen(exec_prefix, L"rb");
+        if (f == NULL) {
+            errno = 0;
+        }
+        else {
+            char buf[MAXPATHLEN+1];
+            wchar_t *rel_builddir_path;
+            n = fread(buf, 1, MAXPATHLEN, f);
+            buf[n] = '\0';
+            fclose(f);
+            rel_builddir_path = _Py_DecodeUTF8_surrogateescape(buf, n);
+            if (rel_builddir_path) {
+                wcsncpy(exec_prefix, calculate->argv0_path, MAXPATHLEN);
+                exec_prefix[MAXPATHLEN] = L'\0';
+                joinpath(exec_prefix, rel_builddir_path);
+                PyMem_RawFree(rel_builddir_path );
+                return -1;
+            }
+        }
+    }
+
+    /* Search from argv0_path, until root is found */
+    copy_absolute(exec_prefix, calculate->argv0_path, MAXPATHLEN+1);
+    do {
+        n = wcslen(exec_prefix);
+        joinpath(exec_prefix, calculate->lib_python);
+        joinpath(exec_prefix, L"lib-dynload");
+        if (isdir(exec_prefix)) {
+            return 1;
+        }
+        exec_prefix[n] = L'\0';
+        reduce(exec_prefix);
+    } while (exec_prefix[0]);
+
+    /* Look at configure's EXEC_PREFIX */
+    wcsncpy(exec_prefix, calculate->exec_prefix, MAXPATHLEN);
+    exec_prefix[MAXPATHLEN] = L'\0';
+    joinpath(exec_prefix, calculate->lib_python);
+    joinpath(exec_prefix, L"lib-dynload");
+    if (isdir(exec_prefix)) {
+        return 1;
+    }
+
+    /* Fail */
+    return 0;
+}
+
+
+static void
+calculate_exec_prefix(const _PyCoreConfig *core_config,
+                      PyCalculatePath *calculate, wchar_t *exec_prefix)
+{
+    calculate->exec_prefix_found = search_for_exec_prefix(core_config,
+                                                          calculate,
+                                                          exec_prefix);
+    if (!calculate->exec_prefix_found) {
+        if (!Py_FrozenFlag) {
+            fprintf(stderr,
+                "Could not find platform dependent libraries <exec_prefix>\n");
+        }
+        wcsncpy(exec_prefix, calculate->exec_prefix, MAXPATHLEN);
+        joinpath(exec_prefix, L"lib/lib-dynload");
+    }
+    /* If we found EXEC_PREFIX do *not* reduce it!  (Yet.) */
+}
+
+
+static void
+calculate_reduce_exec_prefix(PyCalculatePath *calculate, wchar_t *exec_prefix)
+{
+    if (calculate->exec_prefix_found > 0) {
+        reduce(exec_prefix);
+        reduce(exec_prefix);
+        reduce(exec_prefix);
+        if (!exec_prefix[0]) {
+            wcscpy(exec_prefix, separator);
+        }
+    }
+    else {
+        wcsncpy(exec_prefix, calculate->exec_prefix, MAXPATHLEN);
+    }
+}
+
+
+static _PyInitError
+calculate_program_full_path(const _PyCoreConfig *core_config,
+                            PyCalculatePath *calculate, _PyPathConfig *config)
+{
+    wchar_t program_full_path[MAXPATHLEN+1];
+    memset(program_full_path, 0, sizeof(program_full_path));
+
+#ifdef __APPLE__
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_4
+    uint32_t nsexeclength = MAXPATHLEN;
+#else
+    unsigned long nsexeclength = MAXPATHLEN;
+#endif
+    char execpath[MAXPATHLEN+1];
+#endif
+
+    /* If there is no slash in the argv0 path, then we have to
+     * assume python is on the user's $PATH, since there's no
+     * other way to find a directory to start the search from.  If
+     * $PATH isn't exported, you lose.
+     */
+    if (wcschr(core_config->program_name, SEP)) {
+        wcsncpy(program_full_path, core_config->program_name, MAXPATHLEN);
+    }
+#ifdef __APPLE__
+     /* On Mac OS X, if a script uses an interpreter of the form
+      * "#!/opt/python2.3/bin/python", the kernel only passes "python"
+      * as argv[0], which falls through to the $PATH search below.
+      * If /opt/python2.3/bin isn't in your path, or is near the end,
+      * this algorithm may incorrectly find /usr/bin/python. To work
+      * around this, we can use _NSGetExecutablePath to get a better
+      * hint of what the intended interpreter was, although this
+      * will fail if a relative path was used. but in that case,
+      * absolutize() should help us out below
+      */
+    else if(0 == _NSGetExecutablePath(execpath, &nsexeclength) &&
+            execpath[0] == SEP)
+    {
+        size_t len;
+        wchar_t *path = Py_DecodeLocale(execpath, &len);
+        if (path == NULL) {
+            return DECODE_LOCALE_ERR("executable path", len);
+        }
+        wcsncpy(program_full_path, path, MAXPATHLEN);
+        PyMem_RawFree(path);
+    }
+#endif /* __APPLE__ */
+    else if (calculate->path_env) {
+        wchar_t *path = calculate->path_env;
+        while (1) {
+            wchar_t *delim = wcschr(path, DELIM);
+
+            if (delim) {
+                size_t len = delim - path;
+                if (len > MAXPATHLEN) {
+                    len = MAXPATHLEN;
+                }
+                wcsncpy(program_full_path, path, len);
+                program_full_path[len] = '\0';
+            }
+            else {
+                wcsncpy(program_full_path, path, MAXPATHLEN);
+            }
+
+            joinpath(program_full_path, core_config->program_name);
+            if (isxfile(program_full_path)) {
+                break;
+            }
+
+            if (!delim) {
+                program_full_path[0] = L'\0';
+                break;
+            }
+            path = delim + 1;
+        }
+    }
+    else {
+        program_full_path[0] = '\0';
+    }
+    if (program_full_path[0] != SEP && program_full_path[0] != '\0') {
+        absolutize(program_full_path);
+    }
+#if defined(__CYGWIN__) || defined(__MINGW32__)
+    /* For these platforms it is necessary to ensure that the .exe suffix
+     * is appended to the filename, otherwise there is potential for
+     * sys.executable to return the name of a directory under the same
+     * path (bpo-28441).
+     */
+    if (program_full_path[0] != '\0') {
+        add_exe_suffix(program_full_path);
+    }
+#endif
+
+    config->program_full_path = _PyMem_RawWcsdup(program_full_path);
+    if (config->program_full_path == NULL) {
+        return _Py_INIT_NO_MEMORY();
+    }
+    return _Py_INIT_OK();
+}
+
+
+static _PyInitError
+calculate_argv0_path(PyCalculatePath *calculate, const wchar_t *program_full_path)
+{
+    wcsncpy(calculate->argv0_path, program_full_path, MAXPATHLEN);
+    calculate->argv0_path[MAXPATHLEN] = '\0';
+
+#ifdef WITH_NEXT_FRAMEWORK
+    NSModule pythonModule;
+
+    /* On Mac OS X we have a special case if we're running from a framework.
+    ** This is because the python home should be set relative to the library,
+    ** which is in the framework, not relative to the executable, which may
+    ** be outside of the framework. Except when we're in the build directory...
+    */
+    pythonModule = NSModuleForSymbol(NSLookupAndBindSymbol("_Py_Initialize"));
+    /* Use dylib functions to find out where the framework was loaded from */
+    const char* modPath = NSLibraryNameForModule(pythonModule);
+    if (modPath != NULL) {
+        /* We're in a framework. */
+        /* See if we might be in the build directory. The framework in the
+        ** build directory is incomplete, it only has the .dylib and a few
+        ** needed symlinks, it doesn't have the Lib directories and such.
+        ** If we're running with the framework from the build directory we must
+        ** be running the interpreter in the build directory, so we use the
+        ** build-directory-specific logic to find Lib and such.
+        */
+        size_t len;
+        wchar_t* wbuf = Py_DecodeLocale(modPath, &len);
+        if (wbuf == NULL) {
+            return DECODE_LOCALE_ERR("framework location", len);
+        }
+
+        wcsncpy(calculate->argv0_path, wbuf, MAXPATHLEN);
+        reduce(calculate->argv0_path);
+        joinpath(calculate->argv0_path, calculate->lib_python);
+        joinpath(calculate->argv0_path, LANDMARK);
+        if (!ismodule(calculate->argv0_path)) {
+            /* We are in the build directory so use the name of the
+               executable - we know that the absolute path is passed */
+            wcsncpy(calculate->argv0_path, program_full_path, MAXPATHLEN);
+        }
+        else {
+            /* Use the location of the library as the program_full_path */
+            wcsncpy(calculate->argv0_path, wbuf, MAXPATHLEN);
+        }
+        PyMem_RawFree(wbuf);
+    }
+#endif
+
+#if HAVE_READLINK
+    wchar_t tmpbuffer[MAXPATHLEN+1];
+    int linklen = _Py_wreadlink(program_full_path, tmpbuffer, MAXPATHLEN);
+    while (linklen != -1) {
+        if (tmpbuffer[0] == SEP) {
+            /* tmpbuffer should never be longer than MAXPATHLEN,
+               but extra check does not hurt */
+            wcsncpy(calculate->argv0_path, tmpbuffer, MAXPATHLEN);
+        }
+        else {
+            /* Interpret relative to program_full_path */
+            reduce(calculate->argv0_path);
+            joinpath(calculate->argv0_path, tmpbuffer);
+        }
+        linklen = _Py_wreadlink(calculate->argv0_path, tmpbuffer, MAXPATHLEN);
+    }
+#endif /* HAVE_READLINK */
+
+    reduce(calculate->argv0_path);
+    /* At this point, argv0_path is guaranteed to be less than
+       MAXPATHLEN bytes long. */
+    return _Py_INIT_OK();
+}
+
+
+/* Search for an "pyvenv.cfg" environment configuration file, first in the
+   executable's directory and then in the parent directory.
+   If found, open it for use when searching for prefixes.
+*/
+static void
+calculate_read_pyenv(PyCalculatePath *calculate)
+{
+    wchar_t tmpbuffer[MAXPATHLEN+1];
+    wchar_t *env_cfg = L"pyvenv.cfg";
+    FILE *env_file;
+
+    wcscpy(tmpbuffer, calculate->argv0_path);
+
+    joinpath(tmpbuffer, env_cfg);
+    env_file = _Py_wfopen(tmpbuffer, L"r");
+    if (env_file == NULL) {
+        errno = 0;
+
+        reduce(tmpbuffer);
+        reduce(tmpbuffer);
+        joinpath(tmpbuffer, env_cfg);
+
+        env_file = _Py_wfopen(tmpbuffer, L"r");
+        if (env_file == NULL) {
+            errno = 0;
+        }
+    }
+
+    if (env_file == NULL) {
+        return;
+    }
+
+    /* Look for a 'home' variable and set argv0_path to it, if found */
+    if (_Py_FindEnvConfigValue(env_file, L"home", tmpbuffer, MAXPATHLEN)) {
+        wcscpy(calculate->argv0_path, tmpbuffer);
+    }
+    fclose(env_file);
+}
+
+
+static void
+calculate_zip_path(PyCalculatePath *calculate, const wchar_t *prefix)
+{
+    wcsncpy(calculate->zip_path, prefix, MAXPATHLEN);
+    calculate->zip_path[MAXPATHLEN] = L'\0';
+
+    if (calculate->prefix_found > 0) {
+        /* Use the reduced prefix returned by Py_GetPrefix() */
+        reduce(calculate->zip_path);
+        reduce(calculate->zip_path);
+    }
+    else {
+        wcsncpy(calculate->zip_path, calculate->prefix, MAXPATHLEN);
+    }
+    joinpath(calculate->zip_path, L"lib/python00.zip");
+
+    /* Replace "00" with version */
+    size_t bufsz = wcslen(calculate->zip_path);
+    calculate->zip_path[bufsz - 6] = VERSION[0];
+    calculate->zip_path[bufsz - 5] = VERSION[2];
+}
+
+
+static _PyInitError
+calculate_module_search_path(const _PyCoreConfig *core_config,
+                             PyCalculatePath *calculate,
+                             const wchar_t *prefix, const wchar_t *exec_prefix,
+                             _PyPathConfig *config)
+{
+    /* Calculate size of return buffer */
+    size_t bufsz = 0;
+    if (core_config->module_search_path_env != NULL) {
+        bufsz += wcslen(core_config->module_search_path_env) + 1;
+    }
+
+    wchar_t *defpath = calculate->pythonpath;
+    size_t prefixsz = wcslen(prefix) + 1;
+    while (1) {
+        wchar_t *delim = wcschr(defpath, DELIM);
+
+        if (defpath[0] != SEP) {
+            /* Paths are relative to prefix */
+            bufsz += prefixsz;
+        }
+
+        if (delim) {
+            bufsz += delim - defpath + 1;
+        }
+        else {
+            bufsz += wcslen(defpath) + 1;
+            break;
+        }
+        defpath = delim + 1;
+    }
+
+    bufsz += wcslen(calculate->zip_path) + 1;
+    bufsz += wcslen(exec_prefix) + 1;
+
+    /* Allocate the buffer */
+    wchar_t *buf = PyMem_RawMalloc(bufsz * sizeof(wchar_t));
+    if (buf == NULL) {
+        return _Py_INIT_NO_MEMORY();
+    }
+    buf[0] = '\0';
+
+    /* Run-time value of $PYTHONPATH goes first */
+    if (core_config->module_search_path_env) {
+        wcscpy(buf, core_config->module_search_path_env);
+        wcscat(buf, delimiter);
+    }
+
+    /* Next is the default zip path */
+    wcscat(buf, calculate->zip_path);
+    wcscat(buf, delimiter);
+
+    /* Next goes merge of compile-time $PYTHONPATH with
+     * dynamically located prefix.
+     */
+    defpath = calculate->pythonpath;
+    while (1) {
+        wchar_t *delim = wcschr(defpath, DELIM);
+
+        if (defpath[0] != SEP) {
+            wcscat(buf, prefix);
+            if (prefixsz >= 2 && prefix[prefixsz - 2] != SEP &&
+                defpath[0] != (delim ? DELIM : L'\0'))
+            {
+                /* not empty */
+                wcscat(buf, separator);
+            }
+        }
+
+        if (delim) {
+            size_t len = delim - defpath + 1;
+            size_t end = wcslen(buf) + len;
+            wcsncat(buf, defpath, len);
+            buf[end] = '\0';
+        }
+        else {
+            wcscat(buf, defpath);
+            break;
+        }
+        defpath = delim + 1;
+    }
+    wcscat(buf, delimiter);
+
+    /* Finally, on goes the directory for dynamic-load modules */
+    wcscat(buf, exec_prefix);
+
+    config->module_search_path = buf;
+    return _Py_INIT_OK();
+}
+
+
+static _PyInitError
+calculate_init(PyCalculatePath *calculate,
+               const _PyCoreConfig *core_config)
+{
+    size_t len;
+    const char *path = getenv("PATH");
+    if (path) {
+        calculate->path_env = Py_DecodeLocale(path, &len);
+        if (!calculate->path_env) {
+            return DECODE_LOCALE_ERR("PATH environment variable", len);
+        }
+    }
+
+    calculate->pythonpath = Py_DecodeLocale(PYTHONPATH, &len);
+    if (!calculate->pythonpath) {
+        return DECODE_LOCALE_ERR("PYTHONPATH define", len);
+    }
+    calculate->prefix = Py_DecodeLocale(PREFIX, &len);
+    if (!calculate->prefix) {
+        return DECODE_LOCALE_ERR("PREFIX define", len);
+    }
+    calculate->exec_prefix = Py_DecodeLocale(EXEC_PREFIX, &len);
+    if (!calculate->prefix) {
+        return DECODE_LOCALE_ERR("EXEC_PREFIX define", len);
+    }
+    calculate->lib_python = Py_DecodeLocale("lib/python" VERSION, &len);
+    if (!calculate->lib_python) {
+        return DECODE_LOCALE_ERR("EXEC_PREFIX define", len);
+    }
+    return _Py_INIT_OK();
+}
+
+
+static void
+calculate_free(PyCalculatePath *calculate)
+{
+    PyMem_RawFree(calculate->pythonpath);
+    PyMem_RawFree(calculate->prefix);
+    PyMem_RawFree(calculate->exec_prefix);
+    PyMem_RawFree(calculate->lib_python);
+    PyMem_RawFree(calculate->path_env);
+}
+
+
+static _PyInitError
+calculate_path_impl(const _PyCoreConfig *core_config,
+                    PyCalculatePath *calculate, _PyPathConfig *config)
+{
+    _PyInitError err;
+
+    err = calculate_program_full_path(core_config, calculate, config);
+    if (_Py_INIT_FAILED(err)) {
+        return err;
+    }
+
+    err = calculate_argv0_path(calculate, config->program_full_path);
+    if (_Py_INIT_FAILED(err)) {
+        return err;
+    }
+
+    calculate_read_pyenv(calculate);
+
+    wchar_t prefix[MAXPATHLEN+1];
+    memset(prefix, 0, sizeof(prefix));
+    calculate_prefix(core_config, calculate, prefix);
+
+    calculate_zip_path(calculate, prefix);
+
+    wchar_t exec_prefix[MAXPATHLEN+1];
+    memset(exec_prefix, 0, sizeof(exec_prefix));
+    calculate_exec_prefix(core_config, calculate, exec_prefix);
+
+    if ((!calculate->prefix_found || !calculate->exec_prefix_found) &&
+        !Py_FrozenFlag)
+    {
+        fprintf(stderr,
+                "Consider setting $PYTHONHOME to <prefix>[:<exec_prefix>]\n");
+    }
+
+    err = calculate_module_search_path(core_config, calculate,
+                                       prefix, exec_prefix, config);
+    if (_Py_INIT_FAILED(err)) {
+        return err;
+    }
+
+    calculate_reduce_prefix(calculate, prefix);
+
+    config->prefix = _PyMem_RawWcsdup(prefix);
+    if (config->prefix == NULL) {
+        return _Py_INIT_NO_MEMORY();
+    }
+
+    calculate_reduce_exec_prefix(calculate, exec_prefix);
+
+    config->exec_prefix = _PyMem_RawWcsdup(exec_prefix);
+    if (config->exec_prefix == NULL) {
+        return _Py_INIT_NO_MEMORY();
+    }
+
+    return _Py_INIT_OK();
+}
+
+
+_PyInitError
+_PyPathConfig_Calculate(_PyPathConfig *config, const _PyCoreConfig *core_config)
+{
+    PyCalculatePath calculate;
+    memset(&calculate, 0, sizeof(calculate));
+
+    _PyInitError err = calculate_init(&calculate, core_config);
+    if (_Py_INIT_FAILED(err)) {
+        goto done;
+    }
+
+    err = calculate_path_impl(core_config, &calculate, config);
+    if (_Py_INIT_FAILED(err)) {
+        goto done;
+    }
+
+    err = _Py_INIT_OK();
+
+done:
+    calculate_free(&calculate);
+    return err;
+}
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/Python/getplatform.c b/Python/getplatform.c
index 81a0f7a..d55396b 100644
--- a/Python/getplatform.c
+++ b/Python/getplatform.c
@@ -10,3 +10,13 @@ Py_GetPlatform(void)
 {
     return PLATFORM;
 }
+
+#ifndef LIB
+#define LIB "lib"
+#endif
+
+const char *
+Py_GetLib(void)
+{
+	return LIB;
+}
diff --git a/Python/sysmodule.c b/Python/sysmodule.c
index cdc2edf..8902f4d 100644
--- a/Python/sysmodule.c
+++ b/Python/sysmodule.c
@@ -2330,6 +2330,8 @@ _PySys_BeginInit(PyObject **sysmod)
                         PyUnicode_FromString(Py_GetCopyright()));
     SET_SYS_FROM_STRING("platform",
                         PyUnicode_FromString(Py_GetPlatform()));
+    SET_SYS_FROM_STRING("lib",
+                        PyUnicode_FromString(Py_GetLib()));
     SET_SYS_FROM_STRING("maxsize",
                         PyLong_FromSsize_t(PY_SSIZE_T_MAX));
     SET_SYS_FROM_STRING("float_info",
diff --git a/Python/sysmodule.c.orig b/Python/sysmodule.c.orig
new file mode 100644
index 0000000..cdc2edf
--- /dev/null
+++ b/Python/sysmodule.c.orig
@@ -0,0 +1,2801 @@
+
+/* System module */
+
+/*
+Various bits of information used by the interpreter are collected in
+module 'sys'.
+Function member:
+- exit(sts): raise SystemExit
+Data members:
+- stdin, stdout, stderr: standard file objects
+- modules: the table of modules (dictionary)
+- path: module search path (list of strings)
+- argv: script arguments (list of strings)
+- ps1, ps2: optional primary and secondary prompts (strings)
+*/
+
+#include "Python.h"
+#include "internal/pystate.h"
+#include "code.h"
+#include "frameobject.h"
+#include "pythread.h"
+
+#include "osdefs.h"
+#include <locale.h>
+
+#ifdef MS_WINDOWS
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#endif /* MS_WINDOWS */
+
+#ifdef MS_COREDLL
+extern void *PyWin_DLLhModule;
+/* A string loaded from the DLL at startup: */
+extern const char *PyWin_DLLVersionString;
+#endif
+
+/*[clinic input]
+module sys
+[clinic start generated code]*/
+/*[clinic end generated code: output=da39a3ee5e6b4b0d input=3726b388feee8cea]*/
+
+#include "clinic/sysmodule.c.h"
+
+_Py_IDENTIFIER(_);
+_Py_IDENTIFIER(__sizeof__);
+_Py_IDENTIFIER(_xoptions);
+_Py_IDENTIFIER(buffer);
+_Py_IDENTIFIER(builtins);
+_Py_IDENTIFIER(encoding);
+_Py_IDENTIFIER(path);
+_Py_IDENTIFIER(stdout);
+_Py_IDENTIFIER(stderr);
+_Py_IDENTIFIER(warnoptions);
+_Py_IDENTIFIER(write);
+
+PyObject *
+_PySys_GetObjectId(_Py_Identifier *key)
+{
+    PyThreadState *tstate = PyThreadState_GET();
+    PyObject *sd = tstate->interp->sysdict;
+    if (sd == NULL)
+        return NULL;
+    return _PyDict_GetItemId(sd, key);
+}
+
+PyObject *
+PySys_GetObject(const char *name)
+{
+    PyThreadState *tstate = PyThreadState_GET();
+    PyObject *sd = tstate->interp->sysdict;
+    if (sd == NULL)
+        return NULL;
+    return PyDict_GetItemString(sd, name);
+}
+
+int
+_PySys_SetObjectId(_Py_Identifier *key, PyObject *v)
+{
+    PyThreadState *tstate = PyThreadState_GET();
+    PyObject *sd = tstate->interp->sysdict;
+    if (v == NULL) {
+        if (_PyDict_GetItemId(sd, key) == NULL)
+            return 0;
+        else
+            return _PyDict_DelItemId(sd, key);
+    }
+    else
+        return _PyDict_SetItemId(sd, key, v);
+}
+
+int
+PySys_SetObject(const char *name, PyObject *v)
+{
+    PyThreadState *tstate = PyThreadState_GET();
+    PyObject *sd = tstate->interp->sysdict;
+    if (v == NULL) {
+        if (PyDict_GetItemString(sd, name) == NULL)
+            return 0;
+        else
+            return PyDict_DelItemString(sd, name);
+    }
+    else
+        return PyDict_SetItemString(sd, name, v);
+}
+
+static PyObject *
+sys_breakpointhook(PyObject *self, PyObject *const *args, Py_ssize_t nargs, PyObject *keywords)
+{
+    assert(!PyErr_Occurred());
+    char *envar = Py_GETENV("PYTHONBREAKPOINT");
+
+    if (envar == NULL || strlen(envar) == 0) {
+        envar = "pdb.set_trace";
+    }
+    else if (!strcmp(envar, "0")) {
+        /* The breakpoint is explicitly no-op'd. */
+        Py_RETURN_NONE;
+    }
+    /* According to POSIX the string returned by getenv() might be invalidated
+     * or the string content might be overwritten by a subsequent call to
+     * getenv().  Since importing a module can performs the getenv() calls,
+     * we need to save a copy of envar. */
+    envar = _PyMem_RawStrdup(envar);
+    if (envar == NULL) {
+        PyErr_NoMemory();
+        return NULL;
+    }
+    const char *last_dot = strrchr(envar, '.');
+    const char *attrname = NULL;
+    PyObject *modulepath = NULL;
+
+    if (last_dot == NULL) {
+        /* The breakpoint is a built-in, e.g. PYTHONBREAKPOINT=int */
+        modulepath = PyUnicode_FromString("builtins");
+        attrname = envar;
+    }
+    else if (last_dot != envar) {
+        /* Split on the last dot; */
+        modulepath = PyUnicode_FromStringAndSize(envar, last_dot - envar);
+        attrname = last_dot + 1;
+    }
+    else {
+        goto warn;
+    }
+    if (modulepath == NULL) {
+        PyMem_RawFree(envar);
+        return NULL;
+    }
+
+    PyObject *fromlist = Py_BuildValue("(s)", attrname);
+    if (fromlist == NULL) {
+        Py_DECREF(modulepath);
+        PyMem_RawFree(envar);
+        return NULL;
+    }
+    PyObject *module = PyImport_ImportModuleLevelObject(
+        modulepath, NULL, NULL, fromlist, 0);
+    Py_DECREF(modulepath);
+    Py_DECREF(fromlist);
+
+    if (module == NULL) {
+        if (PyErr_ExceptionMatches(PyExc_ImportError)) {
+            goto warn;
+        }
+        PyMem_RawFree(envar);
+        return NULL;
+    }
+
+    PyObject *hook = PyObject_GetAttrString(module, attrname);
+    Py_DECREF(module);
+
+    if (hook == NULL) {
+        if (PyErr_ExceptionMatches(PyExc_AttributeError)) {
+            goto warn;
+        }
+        PyMem_RawFree(envar);
+        return NULL;
+    }
+    PyMem_RawFree(envar);
+    PyObject *retval = _PyObject_FastCallKeywords(hook, args, nargs, keywords);
+    Py_DECREF(hook);
+    return retval;
+
+  warn:
+    /* If any of the imports went wrong, then warn and ignore. */
+    PyErr_Clear();
+    int status = PyErr_WarnFormat(
+        PyExc_RuntimeWarning, 0,
+        "Ignoring unimportable $PYTHONBREAKPOINT: \"%s\"", envar);
+    PyMem_RawFree(envar);
+    if (status < 0) {
+        /* Printing the warning raised an exception. */
+        return NULL;
+    }
+    /* The warning was (probably) issued. */
+    Py_RETURN_NONE;
+}
+
+PyDoc_STRVAR(breakpointhook_doc,
+"breakpointhook(*args, **kws)\n"
+"\n"
+"This hook function is called by built-in breakpoint().\n"
+);
+
+/* Write repr(o) to sys.stdout using sys.stdout.encoding and 'backslashreplace'
+   error handler. If sys.stdout has a buffer attribute, use
+   sys.stdout.buffer.write(encoded), otherwise redecode the string and use
+   sys.stdout.write(redecoded).
+
+   Helper function for sys_displayhook(). */
+static int
+sys_displayhook_unencodable(PyObject *outf, PyObject *o)
+{
+    PyObject *stdout_encoding = NULL;
+    PyObject *encoded, *escaped_str, *repr_str, *buffer, *result;
+    const char *stdout_encoding_str;
+    int ret;
+
+    stdout_encoding = _PyObject_GetAttrId(outf, &PyId_encoding);
+    if (stdout_encoding == NULL)
+        goto error;
+    stdout_encoding_str = PyUnicode_AsUTF8(stdout_encoding);
+    if (stdout_encoding_str == NULL)
+        goto error;
+
+    repr_str = PyObject_Repr(o);
+    if (repr_str == NULL)
+        goto error;
+    encoded = PyUnicode_AsEncodedString(repr_str,
+                                        stdout_encoding_str,
+                                        "backslashreplace");
+    Py_DECREF(repr_str);
+    if (encoded == NULL)
+        goto error;
+
+    buffer = _PyObject_GetAttrId(outf, &PyId_buffer);
+    if (buffer) {
+        result = _PyObject_CallMethodIdObjArgs(buffer, &PyId_write, encoded, NULL);
+        Py_DECREF(buffer);
+        Py_DECREF(encoded);
+        if (result == NULL)
+            goto error;
+        Py_DECREF(result);
+    }
+    else {
+        PyErr_Clear();
+        escaped_str = PyUnicode_FromEncodedObject(encoded,
+                                                  stdout_encoding_str,
+                                                  "strict");
+        Py_DECREF(encoded);
+        if (PyFile_WriteObject(escaped_str, outf, Py_PRINT_RAW) != 0) {
+            Py_DECREF(escaped_str);
+            goto error;
+        }
+        Py_DECREF(escaped_str);
+    }
+    ret = 0;
+    goto finally;
+
+error:
+    ret = -1;
+finally:
+    Py_XDECREF(stdout_encoding);
+    return ret;
+}
+
+static PyObject *
+sys_displayhook(PyObject *self, PyObject *o)
+{
+    PyObject *outf;
+    PyObject *builtins;
+    static PyObject *newline = NULL;
+    int err;
+
+    builtins = _PyImport_GetModuleId(&PyId_builtins);
+    if (builtins == NULL) {
+        PyErr_SetString(PyExc_RuntimeError, "lost builtins module");
+        return NULL;
+    }
+    Py_DECREF(builtins);
+
+    /* Print value except if None */
+    /* After printing, also assign to '_' */
+    /* Before, set '_' to None to avoid recursion */
+    if (o == Py_None) {
+        Py_RETURN_NONE;
+    }
+    if (_PyObject_SetAttrId(builtins, &PyId__, Py_None) != 0)
+        return NULL;
+    outf = _PySys_GetObjectId(&PyId_stdout);
+    if (outf == NULL || outf == Py_None) {
+        PyErr_SetString(PyExc_RuntimeError, "lost sys.stdout");
+        return NULL;
+    }
+    if (PyFile_WriteObject(o, outf, 0) != 0) {
+        if (PyErr_ExceptionMatches(PyExc_UnicodeEncodeError)) {
+            /* repr(o) is not encodable to sys.stdout.encoding with
+             * sys.stdout.errors error handler (which is probably 'strict') */
+            PyErr_Clear();
+            err = sys_displayhook_unencodable(outf, o);
+            if (err)
+                return NULL;
+        }
+        else {
+            return NULL;
+        }
+    }
+    if (newline == NULL) {
+        newline = PyUnicode_FromString("\n");
+        if (newline == NULL)
+            return NULL;
+    }
+    if (PyFile_WriteObject(newline, outf, Py_PRINT_RAW) != 0)
+        return NULL;
+    if (_PyObject_SetAttrId(builtins, &PyId__, o) != 0)
+        return NULL;
+    Py_RETURN_NONE;
+}
+
+PyDoc_STRVAR(displayhook_doc,
+"displayhook(object) -> None\n"
+"\n"
+"Print an object to sys.stdout and also save it in builtins._\n"
+);
+
+static PyObject *
+sys_excepthook(PyObject* self, PyObject* args)
+{
+    PyObject *exc, *value, *tb;
+    if (!PyArg_UnpackTuple(args, "excepthook", 3, 3, &exc, &value, &tb))
+        return NULL;
+    PyErr_Display(exc, value, tb);
+    Py_RETURN_NONE;
+}
+
+PyDoc_STRVAR(excepthook_doc,
+"excepthook(exctype, value, traceback) -> None\n"
+"\n"
+"Handle an exception by displaying it with a traceback on sys.stderr.\n"
+);
+
+static PyObject *
+sys_exc_info(PyObject *self, PyObject *noargs)
+{
+    _PyErr_StackItem *err_info = _PyErr_GetTopmostException(PyThreadState_GET());
+    return Py_BuildValue(
+        "(OOO)",
+        err_info->exc_type != NULL ? err_info->exc_type : Py_None,
+        err_info->exc_value != NULL ? err_info->exc_value : Py_None,
+        err_info->exc_traceback != NULL ?
+            err_info->exc_traceback : Py_None);
+}
+
+PyDoc_STRVAR(exc_info_doc,
+"exc_info() -> (type, value, traceback)\n\
+\n\
+Return information about the most recent exception caught by an except\n\
+clause in the current stack frame or in an older stack frame."
+);
+
+static PyObject *
+sys_exit(PyObject *self, PyObject *args)
+{
+    PyObject *exit_code = 0;
+    if (!PyArg_UnpackTuple(args, "exit", 0, 1, &exit_code))
+        return NULL;
+    /* Raise SystemExit so callers may catch it or clean up. */
+    PyErr_SetObject(PyExc_SystemExit, exit_code);
+    return NULL;
+}
+
+PyDoc_STRVAR(exit_doc,
+"exit([status])\n\
+\n\
+Exit the interpreter by raising SystemExit(status).\n\
+If the status is omitted or None, it defaults to zero (i.e., success).\n\
+If the status is an integer, it will be used as the system exit status.\n\
+If it is another kind of object, it will be printed and the system\n\
+exit status will be one (i.e., failure)."
+);
+
+
+static PyObject *
+sys_getdefaultencoding(PyObject *self)
+{
+    return PyUnicode_FromString(PyUnicode_GetDefaultEncoding());
+}
+
+PyDoc_STRVAR(getdefaultencoding_doc,
+"getdefaultencoding() -> string\n\
+\n\
+Return the current default string encoding used by the Unicode \n\
+implementation."
+);
+
+static PyObject *
+sys_getfilesystemencoding(PyObject *self)
+{
+    if (Py_FileSystemDefaultEncoding)
+        return PyUnicode_FromString(Py_FileSystemDefaultEncoding);
+    PyErr_SetString(PyExc_RuntimeError,
+                    "filesystem encoding is not initialized");
+    return NULL;
+}
+
+PyDoc_STRVAR(getfilesystemencoding_doc,
+"getfilesystemencoding() -> string\n\
+\n\
+Return the encoding used to convert Unicode filenames in\n\
+operating system filenames."
+);
+
+static PyObject *
+sys_getfilesystemencodeerrors(PyObject *self)
+{
+    if (Py_FileSystemDefaultEncodeErrors)
+        return PyUnicode_FromString(Py_FileSystemDefaultEncodeErrors);
+    PyErr_SetString(PyExc_RuntimeError,
+        "filesystem encoding is not initialized");
+    return NULL;
+}
+
+PyDoc_STRVAR(getfilesystemencodeerrors_doc,
+    "getfilesystemencodeerrors() -> string\n\
+\n\
+Return the error mode used to convert Unicode filenames in\n\
+operating system filenames."
+);
+
+static PyObject *
+sys_intern(PyObject *self, PyObject *args)
+{
+    PyObject *s;
+    if (!PyArg_ParseTuple(args, "U:intern", &s))
+        return NULL;
+    if (PyUnicode_CheckExact(s)) {
+        Py_INCREF(s);
+        PyUnicode_InternInPlace(&s);
+        return s;
+    }
+    else {
+        PyErr_Format(PyExc_TypeError,
+                        "can't intern %.400s", s->ob_type->tp_name);
+        return NULL;
+    }
+}
+
+PyDoc_STRVAR(intern_doc,
+"intern(string) -> string\n\
+\n\
+``Intern'' the given string.  This enters the string in the (global)\n\
+table of interned strings whose purpose is to speed up dictionary lookups.\n\
+Return the string itself or the previously interned string object with the\n\
+same value.");
+
+
+/*
+ * Cached interned string objects used for calling the profile and
+ * trace functions.  Initialized by trace_init().
+ */
+static PyObject *whatstrings[8] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
+
+static int
+trace_init(void)
+{
+    static const char * const whatnames[8] = {
+        "call", "exception", "line", "return",
+        "c_call", "c_exception", "c_return",
+        "opcode"
+    };
+    PyObject *name;
+    int i;
+    for (i = 0; i < 8; ++i) {
+        if (whatstrings[i] == NULL) {
+            name = PyUnicode_InternFromString(whatnames[i]);
+            if (name == NULL)
+                return -1;
+            whatstrings[i] = name;
+        }
+    }
+    return 0;
+}
+
+
+static PyObject *
+call_trampoline(PyObject* callback,
+                PyFrameObject *frame, int what, PyObject *arg)
+{
+    PyObject *result;
+    PyObject *stack[3];
+
+    if (PyFrame_FastToLocalsWithError(frame) < 0) {
+        return NULL;
+    }
+
+    stack[0] = (PyObject *)frame;
+    stack[1] = whatstrings[what];
+    stack[2] = (arg != NULL) ? arg : Py_None;
+
+    /* call the Python-level function */
+    result = _PyObject_FastCall(callback, stack, 3);
+
+    PyFrame_LocalsToFast(frame, 1);
+    if (result == NULL) {
+        PyTraceBack_Here(frame);
+    }
+
+    return result;
+}
+
+static int
+profile_trampoline(PyObject *self, PyFrameObject *frame,
+                   int what, PyObject *arg)
+{
+    PyObject *result;
+
+    if (arg == NULL)
+        arg = Py_None;
+    result = call_trampoline(self, frame, what, arg);
+    if (result == NULL) {
+        PyEval_SetProfile(NULL, NULL);
+        return -1;
+    }
+    Py_DECREF(result);
+    return 0;
+}
+
+static int
+trace_trampoline(PyObject *self, PyFrameObject *frame,
+                 int what, PyObject *arg)
+{
+    PyObject *callback;
+    PyObject *result;
+
+    if (what == PyTrace_CALL)
+        callback = self;
+    else
+        callback = frame->f_trace;
+    if (callback == NULL)
+        return 0;
+    result = call_trampoline(callback, frame, what, arg);
+    if (result == NULL) {
+        PyEval_SetTrace(NULL, NULL);
+        Py_CLEAR(frame->f_trace);
+        return -1;
+    }
+    if (result != Py_None) {
+        Py_XSETREF(frame->f_trace, result);
+    }
+    else {
+        Py_DECREF(result);
+    }
+    return 0;
+}
+
+static PyObject *
+sys_settrace(PyObject *self, PyObject *args)
+{
+    if (trace_init() == -1)
+        return NULL;
+    if (args == Py_None)
+        PyEval_SetTrace(NULL, NULL);
+    else
+        PyEval_SetTrace(trace_trampoline, args);
+    Py_RETURN_NONE;
+}
+
+PyDoc_STRVAR(settrace_doc,
+"settrace(function)\n\
+\n\
+Set the global debug tracing function.  It will be called on each\n\
+function call.  See the debugger chapter in the library manual."
+);
+
+static PyObject *
+sys_gettrace(PyObject *self, PyObject *args)
+{
+    PyThreadState *tstate = PyThreadState_GET();
+    PyObject *temp = tstate->c_traceobj;
+
+    if (temp == NULL)
+        temp = Py_None;
+    Py_INCREF(temp);
+    return temp;
+}
+
+PyDoc_STRVAR(gettrace_doc,
+"gettrace()\n\
+\n\
+Return the global debug tracing function set with sys.settrace.\n\
+See the debugger chapter in the library manual."
+);
+
+static PyObject *
+sys_setprofile(PyObject *self, PyObject *args)
+{
+    if (trace_init() == -1)
+        return NULL;
+    if (args == Py_None)
+        PyEval_SetProfile(NULL, NULL);
+    else
+        PyEval_SetProfile(profile_trampoline, args);
+    Py_RETURN_NONE;
+}
+
+PyDoc_STRVAR(setprofile_doc,
+"setprofile(function)\n\
+\n\
+Set the profiling function.  It will be called on each function call\n\
+and return.  See the profiler chapter in the library manual."
+);
+
+static PyObject *
+sys_getprofile(PyObject *self, PyObject *args)
+{
+    PyThreadState *tstate = PyThreadState_GET();
+    PyObject *temp = tstate->c_profileobj;
+
+    if (temp == NULL)
+        temp = Py_None;
+    Py_INCREF(temp);
+    return temp;
+}
+
+PyDoc_STRVAR(getprofile_doc,
+"getprofile()\n\
+\n\
+Return the profiling function set with sys.setprofile.\n\
+See the profiler chapter in the library manual."
+);
+
+static PyObject *
+sys_setcheckinterval(PyObject *self, PyObject *args)
+{
+    if (PyErr_WarnEx(PyExc_DeprecationWarning,
+                     "sys.getcheckinterval() and sys.setcheckinterval() "
+                     "are deprecated.  Use sys.setswitchinterval() "
+                     "instead.", 1) < 0)
+        return NULL;
+    PyInterpreterState *interp = PyThreadState_GET()->interp;
+    if (!PyArg_ParseTuple(args, "i:setcheckinterval", &interp->check_interval))
+        return NULL;
+    Py_RETURN_NONE;
+}
+
+PyDoc_STRVAR(setcheckinterval_doc,
+"setcheckinterval(n)\n\
+\n\
+Tell the Python interpreter to check for asynchronous events every\n\
+n instructions.  This also affects how often thread switches occur."
+);
+
+static PyObject *
+sys_getcheckinterval(PyObject *self, PyObject *args)
+{
+    if (PyErr_WarnEx(PyExc_DeprecationWarning,
+                     "sys.getcheckinterval() and sys.setcheckinterval() "
+                     "are deprecated.  Use sys.getswitchinterval() "
+                     "instead.", 1) < 0)
+        return NULL;
+    PyInterpreterState *interp = PyThreadState_GET()->interp;
+    return PyLong_FromLong(interp->check_interval);
+}
+
+PyDoc_STRVAR(getcheckinterval_doc,
+"getcheckinterval() -> current check interval; see setcheckinterval()."
+);
+
+static PyObject *
+sys_setswitchinterval(PyObject *self, PyObject *args)
+{
+    double d;
+    if (!PyArg_ParseTuple(args, "d:setswitchinterval", &d))
+        return NULL;
+    if (d <= 0.0) {
+        PyErr_SetString(PyExc_ValueError,
+                        "switch interval must be strictly positive");
+        return NULL;
+    }
+    _PyEval_SetSwitchInterval((unsigned long) (1e6 * d));
+    Py_RETURN_NONE;
+}
+
+PyDoc_STRVAR(setswitchinterval_doc,
+"setswitchinterval(n)\n\
+\n\
+Set the ideal thread switching delay inside the Python interpreter\n\
+The actual frequency of switching threads can be lower if the\n\
+interpreter executes long sequences of uninterruptible code\n\
+(this is implementation-specific and workload-dependent).\n\
+\n\
+The parameter must represent the desired switching delay in seconds\n\
+A typical value is 0.005 (5 milliseconds)."
+);
+
+static PyObject *
+sys_getswitchinterval(PyObject *self, PyObject *args)
+{
+    return PyFloat_FromDouble(1e-6 * _PyEval_GetSwitchInterval());
+}
+
+PyDoc_STRVAR(getswitchinterval_doc,
+"getswitchinterval() -> current thread switch interval; see setswitchinterval()."
+);
+
+static PyObject *
+sys_setrecursionlimit(PyObject *self, PyObject *args)
+{
+    int new_limit, mark;
+    PyThreadState *tstate;
+
+    if (!PyArg_ParseTuple(args, "i:setrecursionlimit", &new_limit))
+        return NULL;
+
+    if (new_limit < 1) {
+        PyErr_SetString(PyExc_ValueError,
+                        "recursion limit must be greater or equal than 1");
+        return NULL;
+    }
+
+    /* Issue #25274: When the recursion depth hits the recursion limit in
+       _Py_CheckRecursiveCall(), the overflowed flag of the thread state is
+       set to 1 and a RecursionError is raised. The overflowed flag is reset
+       to 0 when the recursion depth goes below the low-water mark: see
+       Py_LeaveRecursiveCall().
+
+       Reject too low new limit if the current recursion depth is higher than
+       the new low-water mark. Otherwise it may not be possible anymore to
+       reset the overflowed flag to 0. */
+    mark = _Py_RecursionLimitLowerWaterMark(new_limit);
+    tstate = PyThreadState_GET();
+    if (tstate->recursion_depth >= mark) {
+        PyErr_Format(PyExc_RecursionError,
+                     "cannot set the recursion limit to %i at "
+                     "the recursion depth %i: the limit is too low",
+                     new_limit, tstate->recursion_depth);
+        return NULL;
+    }
+
+    Py_SetRecursionLimit(new_limit);
+    Py_RETURN_NONE;
+}
+
+/*[clinic input]
+sys.set_coroutine_origin_tracking_depth
+
+  depth: int
+
+Enable or disable origin tracking for coroutine objects in this thread.
+
+Coroutine objects will track 'depth' frames of traceback information about
+where they came from, available in their cr_origin attribute. Set depth of 0
+to disable.
+[clinic start generated code]*/
+
+static PyObject *
+sys_set_coroutine_origin_tracking_depth_impl(PyObject *module, int depth)
+/*[clinic end generated code: output=0a2123c1cc6759c5 input=9083112cccc1bdcb]*/
+{
+    if (depth < 0) {
+        PyErr_SetString(PyExc_ValueError, "depth must be >= 0");
+        return NULL;
+    }
+    _PyEval_SetCoroutineOriginTrackingDepth(depth);
+    Py_RETURN_NONE;
+}
+
+/*[clinic input]
+sys.get_coroutine_origin_tracking_depth -> int
+
+Check status of origin tracking for coroutine objects in this thread.
+[clinic start generated code]*/
+
+static int
+sys_get_coroutine_origin_tracking_depth_impl(PyObject *module)
+/*[clinic end generated code: output=3699f7be95a3afb8 input=335266a71205b61a]*/
+{
+    return _PyEval_GetCoroutineOriginTrackingDepth();
+}
+
+static PyObject *
+sys_set_coroutine_wrapper(PyObject *self, PyObject *wrapper)
+{
+    if (PyErr_WarnEx(PyExc_DeprecationWarning,
+                     "set_coroutine_wrapper is deprecated", 1) < 0) {
+        return NULL;
+    }
+
+    if (wrapper != Py_None) {
+        if (!PyCallable_Check(wrapper)) {
+            PyErr_Format(PyExc_TypeError,
+                         "callable expected, got %.50s",
+                         Py_TYPE(wrapper)->tp_name);
+            return NULL;
+        }
+        _PyEval_SetCoroutineWrapper(wrapper);
+    }
+    else {
+        _PyEval_SetCoroutineWrapper(NULL);
+    }
+    Py_RETURN_NONE;
+}
+
+PyDoc_STRVAR(set_coroutine_wrapper_doc,
+"set_coroutine_wrapper(wrapper)\n\
+\n\
+Set a wrapper for coroutine objects."
+);
+
+static PyObject *
+sys_get_coroutine_wrapper(PyObject *self, PyObject *args)
+{
+    if (PyErr_WarnEx(PyExc_DeprecationWarning,
+                     "get_coroutine_wrapper is deprecated", 1) < 0) {
+        return NULL;
+    }
+    PyObject *wrapper = _PyEval_GetCoroutineWrapper();
+    if (wrapper == NULL) {
+        wrapper = Py_None;
+    }
+    Py_INCREF(wrapper);
+    return wrapper;
+}
+
+PyDoc_STRVAR(get_coroutine_wrapper_doc,
+"get_coroutine_wrapper()\n\
+\n\
+Return the wrapper for coroutine objects set by sys.set_coroutine_wrapper."
+);
+
+
+static PyTypeObject AsyncGenHooksType;
+
+PyDoc_STRVAR(asyncgen_hooks_doc,
+"asyncgen_hooks\n\
+\n\
+A struct sequence providing information about asynhronous\n\
+generators hooks.  The attributes are read only.");
+
+static PyStructSequence_Field asyncgen_hooks_fields[] = {
+    {"firstiter", "Hook to intercept first iteration"},
+    {"finalizer", "Hook to intercept finalization"},
+    {0}
+};
+
+static PyStructSequence_Desc asyncgen_hooks_desc = {
+    "asyncgen_hooks",          /* name */
+    asyncgen_hooks_doc,        /* doc */
+    asyncgen_hooks_fields ,    /* fields */
+    2
+};
+
+
+static PyObject *
+sys_set_asyncgen_hooks(PyObject *self, PyObject *args, PyObject *kw)
+{
+    static char *keywords[] = {"firstiter", "finalizer", NULL};
+    PyObject *firstiter = NULL;
+    PyObject *finalizer = NULL;
+
+    if (!PyArg_ParseTupleAndKeywords(
+            args, kw, "|OO", keywords,
+            &firstiter, &finalizer)) {
+        return NULL;
+    }
+
+    if (finalizer && finalizer != Py_None) {
+        if (!PyCallable_Check(finalizer)) {
+            PyErr_Format(PyExc_TypeError,
+                         "callable finalizer expected, got %.50s",
+                         Py_TYPE(finalizer)->tp_name);
+            return NULL;
+        }
+        _PyEval_SetAsyncGenFinalizer(finalizer);
+    }
+    else if (finalizer == Py_None) {
+        _PyEval_SetAsyncGenFinalizer(NULL);
+    }
+
+    if (firstiter && firstiter != Py_None) {
+        if (!PyCallable_Check(firstiter)) {
+            PyErr_Format(PyExc_TypeError,
+                         "callable firstiter expected, got %.50s",
+                         Py_TYPE(firstiter)->tp_name);
+            return NULL;
+        }
+        _PyEval_SetAsyncGenFirstiter(firstiter);
+    }
+    else if (firstiter == Py_None) {
+        _PyEval_SetAsyncGenFirstiter(NULL);
+    }
+
+    Py_RETURN_NONE;
+}
+
+PyDoc_STRVAR(set_asyncgen_hooks_doc,
+"set_asyncgen_hooks(*, firstiter=None, finalizer=None)\n\
+\n\
+Set a finalizer for async generators objects."
+);
+
+static PyObject *
+sys_get_asyncgen_hooks(PyObject *self, PyObject *args)
+{
+    PyObject *res;
+    PyObject *firstiter = _PyEval_GetAsyncGenFirstiter();
+    PyObject *finalizer = _PyEval_GetAsyncGenFinalizer();
+
+    res = PyStructSequence_New(&AsyncGenHooksType);
+    if (res == NULL) {
+        return NULL;
+    }
+
+    if (firstiter == NULL) {
+        firstiter = Py_None;
+    }
+
+    if (finalizer == NULL) {
+        finalizer = Py_None;
+    }
+
+    Py_INCREF(firstiter);
+    PyStructSequence_SET_ITEM(res, 0, firstiter);
+
+    Py_INCREF(finalizer);
+    PyStructSequence_SET_ITEM(res, 1, finalizer);
+
+    return res;
+}
+
+PyDoc_STRVAR(get_asyncgen_hooks_doc,
+"get_asyncgen_hooks()\n\
+\n\
+Return a namedtuple of installed asynchronous generators hooks \
+(firstiter, finalizer)."
+);
+
+
+static PyTypeObject Hash_InfoType;
+
+PyDoc_STRVAR(hash_info_doc,
+"hash_info\n\
+\n\
+A struct sequence providing parameters used for computing\n\
+hashes. The attributes are read only.");
+
+static PyStructSequence_Field hash_info_fields[] = {
+    {"width", "width of the type used for hashing, in bits"},
+    {"modulus", "prime number giving the modulus on which the hash "
+                "function is based"},
+    {"inf", "value to be used for hash of a positive infinity"},
+    {"nan", "value to be used for hash of a nan"},
+    {"imag", "multiplier used for the imaginary part of a complex number"},
+    {"algorithm", "name of the algorithm for hashing of str, bytes and "
+                  "memoryviews"},
+    {"hash_bits", "internal output size of hash algorithm"},
+    {"seed_bits", "seed size of hash algorithm"},
+    {"cutoff", "small string optimization cutoff"},
+    {NULL, NULL}
+};
+
+static PyStructSequence_Desc hash_info_desc = {
+    "sys.hash_info",
+    hash_info_doc,
+    hash_info_fields,
+    9,
+};
+
+static PyObject *
+get_hash_info(void)
+{
+    PyObject *hash_info;
+    int field = 0;
+    PyHash_FuncDef *hashfunc;
+    hash_info = PyStructSequence_New(&Hash_InfoType);
+    if (hash_info == NULL)
+        return NULL;
+    hashfunc = PyHash_GetFuncDef();
+    PyStructSequence_SET_ITEM(hash_info, field++,
+                              PyLong_FromLong(8*sizeof(Py_hash_t)));
+    PyStructSequence_SET_ITEM(hash_info, field++,
+                              PyLong_FromSsize_t(_PyHASH_MODULUS));
+    PyStructSequence_SET_ITEM(hash_info, field++,
+                              PyLong_FromLong(_PyHASH_INF));
+    PyStructSequence_SET_ITEM(hash_info, field++,
+                              PyLong_FromLong(_PyHASH_NAN));
+    PyStructSequence_SET_ITEM(hash_info, field++,
+                              PyLong_FromLong(_PyHASH_IMAG));
+    PyStructSequence_SET_ITEM(hash_info, field++,
+                              PyUnicode_FromString(hashfunc->name));
+    PyStructSequence_SET_ITEM(hash_info, field++,
+                              PyLong_FromLong(hashfunc->hash_bits));
+    PyStructSequence_SET_ITEM(hash_info, field++,
+                              PyLong_FromLong(hashfunc->seed_bits));
+    PyStructSequence_SET_ITEM(hash_info, field++,
+                              PyLong_FromLong(Py_HASH_CUTOFF));
+    if (PyErr_Occurred()) {
+        Py_CLEAR(hash_info);
+        return NULL;
+    }
+    return hash_info;
+}
+
+
+PyDoc_STRVAR(setrecursionlimit_doc,
+"setrecursionlimit(n)\n\
+\n\
+Set the maximum depth of the Python interpreter stack to n.  This\n\
+limit prevents infinite recursion from causing an overflow of the C\n\
+stack and crashing Python.  The highest possible limit is platform-\n\
+dependent."
+);
+
+static PyObject *
+sys_getrecursionlimit(PyObject *self)
+{
+    return PyLong_FromLong(Py_GetRecursionLimit());
+}
+
+PyDoc_STRVAR(getrecursionlimit_doc,
+"getrecursionlimit()\n\
+\n\
+Return the current value of the recursion limit, the maximum depth\n\
+of the Python interpreter stack.  This limit prevents infinite\n\
+recursion from causing an overflow of the C stack and crashing Python."
+);
+
+#ifdef MS_WINDOWS
+PyDoc_STRVAR(getwindowsversion_doc,
+"getwindowsversion()\n\
+\n\
+Return information about the running version of Windows as a named tuple.\n\
+The members are named: major, minor, build, platform, service_pack,\n\
+service_pack_major, service_pack_minor, suite_mask, and product_type. For\n\
+backward compatibility, only the first 5 items are available by indexing.\n\
+All elements are numbers, except service_pack and platform_type which are\n\
+strings, and platform_version which is a 3-tuple. Platform is always 2.\n\
+Product_type may be 1 for a workstation, 2 for a domain controller, 3 for a\n\
+server. Platform_version is a 3-tuple containing a version number that is\n\
+intended for identifying the OS rather than feature detection."
+);
+
+static PyTypeObject WindowsVersionType = {0, 0, 0, 0, 0, 0};
+
+static PyStructSequence_Field windows_version_fields[] = {
+    {"major", "Major version number"},
+    {"minor", "Minor version number"},
+    {"build", "Build number"},
+    {"platform", "Operating system platform"},
+    {"service_pack", "Latest Service Pack installed on the system"},
+    {"service_pack_major", "Service Pack major version number"},
+    {"service_pack_minor", "Service Pack minor version number"},
+    {"suite_mask", "Bit mask identifying available product suites"},
+    {"product_type", "System product type"},
+    {"platform_version", "Diagnostic version number"},
+    {0}
+};
+
+static PyStructSequence_Desc windows_version_desc = {
+    "sys.getwindowsversion",  /* name */
+    getwindowsversion_doc,    /* doc */
+    windows_version_fields,   /* fields */
+    5                         /* For backward compatibility,
+                                 only the first 5 items are accessible
+                                 via indexing, the rest are name only */
+};
+
+/* Disable deprecation warnings about GetVersionEx as the result is
+   being passed straight through to the caller, who is responsible for
+   using it correctly. */
+#pragma warning(push)
+#pragma warning(disable:4996)
+
+static PyObject *
+sys_getwindowsversion(PyObject *self)
+{
+    PyObject *version;
+    int pos = 0;
+    OSVERSIONINFOEX ver;
+    DWORD realMajor, realMinor, realBuild;
+    HANDLE hKernel32;
+    wchar_t kernel32_path[MAX_PATH];
+    LPVOID verblock;
+    DWORD verblock_size;
+
+    ver.dwOSVersionInfoSize = sizeof(ver);
+    if (!GetVersionEx((OSVERSIONINFO*) &ver))
+        return PyErr_SetFromWindowsErr(0);
+
+    version = PyStructSequence_New(&WindowsVersionType);
+    if (version == NULL)
+        return NULL;
+
+    PyStructSequence_SET_ITEM(version, pos++, PyLong_FromLong(ver.dwMajorVersion));
+    PyStructSequence_SET_ITEM(version, pos++, PyLong_FromLong(ver.dwMinorVersion));
+    PyStructSequence_SET_ITEM(version, pos++, PyLong_FromLong(ver.dwBuildNumber));
+    PyStructSequence_SET_ITEM(version, pos++, PyLong_FromLong(ver.dwPlatformId));
+    PyStructSequence_SET_ITEM(version, pos++, PyUnicode_FromString(ver.szCSDVersion));
+    PyStructSequence_SET_ITEM(version, pos++, PyLong_FromLong(ver.wServicePackMajor));
+    PyStructSequence_SET_ITEM(version, pos++, PyLong_FromLong(ver.wServicePackMinor));
+    PyStructSequence_SET_ITEM(version, pos++, PyLong_FromLong(ver.wSuiteMask));
+    PyStructSequence_SET_ITEM(version, pos++, PyLong_FromLong(ver.wProductType));
+
+    realMajor = ver.dwMajorVersion;
+    realMinor = ver.dwMinorVersion;
+    realBuild = ver.dwBuildNumber;
+
+    // GetVersion will lie if we are running in a compatibility mode.
+    // We need to read the version info from a system file resource
+    // to accurately identify the OS version. If we fail for any reason,
+    // just return whatever GetVersion said.
+    hKernel32 = GetModuleHandleW(L"kernel32.dll");
+    if (hKernel32 && GetModuleFileNameW(hKernel32, kernel32_path, MAX_PATH) &&
+        (verblock_size = GetFileVersionInfoSizeW(kernel32_path, NULL)) &&
+        (verblock = PyMem_RawMalloc(verblock_size))) {
+        VS_FIXEDFILEINFO *ffi;
+        UINT ffi_len;
+
+        if (GetFileVersionInfoW(kernel32_path, 0, verblock_size, verblock) &&
+            VerQueryValueW(verblock, L"", (LPVOID)&ffi, &ffi_len)) {
+            realMajor = HIWORD(ffi->dwProductVersionMS);
+            realMinor = LOWORD(ffi->dwProductVersionMS);
+            realBuild = HIWORD(ffi->dwProductVersionLS);
+        }
+        PyMem_RawFree(verblock);
+    }
+    PyStructSequence_SET_ITEM(version, pos++, Py_BuildValue("(kkk)",
+        realMajor,
+        realMinor,
+        realBuild
+    ));
+
+    if (PyErr_Occurred()) {
+        Py_DECREF(version);
+        return NULL;
+    }
+
+    return version;
+}
+
+#pragma warning(pop)
+
+PyDoc_STRVAR(enablelegacywindowsfsencoding_doc,
+"_enablelegacywindowsfsencoding()\n\
+\n\
+Changes the default filesystem encoding to mbcs:replace for consistency\n\
+with earlier versions of Python. See PEP 529 for more information.\n\
+\n\
+This is equivalent to defining the PYTHONLEGACYWINDOWSFSENCODING \n\
+environment variable before launching Python."
+);
+
+static PyObject *
+sys_enablelegacywindowsfsencoding(PyObject *self)
+{
+    Py_FileSystemDefaultEncoding = "mbcs";
+    Py_FileSystemDefaultEncodeErrors = "replace";
+    Py_RETURN_NONE;
+}
+
+#endif /* MS_WINDOWS */
+
+#ifdef HAVE_DLOPEN
+static PyObject *
+sys_setdlopenflags(PyObject *self, PyObject *args)
+{
+    int new_val;
+    PyThreadState *tstate = PyThreadState_GET();
+    if (!PyArg_ParseTuple(args, "i:setdlopenflags", &new_val))
+        return NULL;
+    if (!tstate)
+        return NULL;
+    tstate->interp->dlopenflags = new_val;
+    Py_RETURN_NONE;
+}
+
+PyDoc_STRVAR(setdlopenflags_doc,
+"setdlopenflags(n) -> None\n\
+\n\
+Set the flags used by the interpreter for dlopen calls, such as when the\n\
+interpreter loads extension modules.  Among other things, this will enable\n\
+a lazy resolving of symbols when importing a module, if called as\n\
+sys.setdlopenflags(0).  To share symbols across extension modules, call as\n\
+sys.setdlopenflags(os.RTLD_GLOBAL).  Symbolic names for the flag modules\n\
+can be found in the os module (RTLD_xxx constants, e.g. os.RTLD_LAZY).");
+
+static PyObject *
+sys_getdlopenflags(PyObject *self, PyObject *args)
+{
+    PyThreadState *tstate = PyThreadState_GET();
+    if (!tstate)
+        return NULL;
+    return PyLong_FromLong(tstate->interp->dlopenflags);
+}
+
+PyDoc_STRVAR(getdlopenflags_doc,
+"getdlopenflags() -> int\n\
+\n\
+Return the current value of the flags that are used for dlopen calls.\n\
+The flag constants are defined in the os module.");
+
+#endif  /* HAVE_DLOPEN */
+
+#ifdef USE_MALLOPT
+/* Link with -lmalloc (or -lmpc) on an SGI */
+#include <malloc.h>
+
+static PyObject *
+sys_mdebug(PyObject *self, PyObject *args)
+{
+    int flag;
+    if (!PyArg_ParseTuple(args, "i:mdebug", &flag))
+        return NULL;
+    mallopt(M_DEBUG, flag);
+    Py_RETURN_NONE;
+}
+#endif /* USE_MALLOPT */
+
+size_t
+_PySys_GetSizeOf(PyObject *o)
+{
+    PyObject *res = NULL;
+    PyObject *method;
+    Py_ssize_t size;
+
+    /* Make sure the type is initialized. float gets initialized late */
+    if (PyType_Ready(Py_TYPE(o)) < 0)
+        return (size_t)-1;
+
+    method = _PyObject_LookupSpecial(o, &PyId___sizeof__);
+    if (method == NULL) {
+        if (!PyErr_Occurred())
+            PyErr_Format(PyExc_TypeError,
+                         "Type %.100s doesn't define __sizeof__",
+                         Py_TYPE(o)->tp_name);
+    }
+    else {
+        res = _PyObject_CallNoArg(method);
+        Py_DECREF(method);
+    }
+
+    if (res == NULL)
+        return (size_t)-1;
+
+    size = PyLong_AsSsize_t(res);
+    Py_DECREF(res);
+    if (size == -1 && PyErr_Occurred())
+        return (size_t)-1;
+
+    if (size < 0) {
+        PyErr_SetString(PyExc_ValueError, "__sizeof__() should return >= 0");
+        return (size_t)-1;
+    }
+
+    /* add gc_head size */
+    if (PyObject_IS_GC(o))
+        return ((size_t)size) + sizeof(PyGC_Head);
+    return (size_t)size;
+}
+
+static PyObject *
+sys_getsizeof(PyObject *self, PyObject *args, PyObject *kwds)
+{
+    static char *kwlist[] = {"object", "default", 0};
+    size_t size;
+    PyObject *o, *dflt = NULL;
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|O:getsizeof",
+                                     kwlist, &o, &dflt))
+        return NULL;
+
+    size = _PySys_GetSizeOf(o);
+
+    if (size == (size_t)-1 && PyErr_Occurred()) {
+        /* Has a default value been given */
+        if (dflt != NULL && PyErr_ExceptionMatches(PyExc_TypeError)) {
+            PyErr_Clear();
+            Py_INCREF(dflt);
+            return dflt;
+        }
+        else
+            return NULL;
+    }
+
+    return PyLong_FromSize_t(size);
+}
+
+PyDoc_STRVAR(getsizeof_doc,
+"getsizeof(object, default) -> int\n\
+\n\
+Return the size of object in bytes.");
+
+static PyObject *
+sys_getrefcount(PyObject *self, PyObject *arg)
+{
+    return PyLong_FromSsize_t(arg->ob_refcnt);
+}
+
+#ifdef Py_REF_DEBUG
+static PyObject *
+sys_gettotalrefcount(PyObject *self)
+{
+    return PyLong_FromSsize_t(_Py_GetRefTotal());
+}
+#endif /* Py_REF_DEBUG */
+
+PyDoc_STRVAR(getrefcount_doc,
+"getrefcount(object) -> integer\n\
+\n\
+Return the reference count of object.  The count returned is generally\n\
+one higher than you might expect, because it includes the (temporary)\n\
+reference as an argument to getrefcount()."
+);
+
+static PyObject *
+sys_getallocatedblocks(PyObject *self)
+{
+    return PyLong_FromSsize_t(_Py_GetAllocatedBlocks());
+}
+
+PyDoc_STRVAR(getallocatedblocks_doc,
+"getallocatedblocks() -> integer\n\
+\n\
+Return the number of memory blocks currently allocated, regardless of their\n\
+size."
+);
+
+#ifdef COUNT_ALLOCS
+static PyObject *
+sys_getcounts(PyObject *self)
+{
+    extern PyObject *get_counts(void);
+
+    return get_counts();
+}
+#endif
+
+PyDoc_STRVAR(getframe_doc,
+"_getframe([depth]) -> frameobject\n\
+\n\
+Return a frame object from the call stack.  If optional integer depth is\n\
+given, return the frame object that many calls below the top of the stack.\n\
+If that is deeper than the call stack, ValueError is raised.  The default\n\
+for depth is zero, returning the frame at the top of the call stack.\n\
+\n\
+This function should be used for internal and specialized\n\
+purposes only."
+);
+
+static PyObject *
+sys_getframe(PyObject *self, PyObject *args)
+{
+    PyFrameObject *f = PyThreadState_GET()->frame;
+    int depth = -1;
+
+    if (!PyArg_ParseTuple(args, "|i:_getframe", &depth))
+        return NULL;
+
+    while (depth > 0 && f != NULL) {
+        f = f->f_back;
+        --depth;
+    }
+    if (f == NULL) {
+        PyErr_SetString(PyExc_ValueError,
+                        "call stack is not deep enough");
+        return NULL;
+    }
+    Py_INCREF(f);
+    return (PyObject*)f;
+}
+
+PyDoc_STRVAR(current_frames_doc,
+"_current_frames() -> dictionary\n\
+\n\
+Return a dictionary mapping each current thread T's thread id to T's\n\
+current stack frame.\n\
+\n\
+This function should be used for specialized purposes only."
+);
+
+static PyObject *
+sys_current_frames(PyObject *self, PyObject *noargs)
+{
+    return _PyThread_CurrentFrames();
+}
+
+PyDoc_STRVAR(call_tracing_doc,
+"call_tracing(func, args) -> object\n\
+\n\
+Call func(*args), while tracing is enabled.  The tracing state is\n\
+saved, and restored afterwards.  This is intended to be called from\n\
+a debugger from a checkpoint, to recursively debug some other code."
+);
+
+static PyObject *
+sys_call_tracing(PyObject *self, PyObject *args)
+{
+    PyObject *func, *funcargs;
+    if (!PyArg_ParseTuple(args, "OO!:call_tracing", &func, &PyTuple_Type, &funcargs))
+        return NULL;
+    return _PyEval_CallTracing(func, funcargs);
+}
+
+PyDoc_STRVAR(callstats_doc,
+"callstats() -> tuple of integers\n\
+\n\
+Return a tuple of function call statistics, if CALL_PROFILE was defined\n\
+when Python was built.  Otherwise, return None.\n\
+\n\
+When enabled, this function returns detailed, implementation-specific\n\
+details about the number of function calls executed. The return value is\n\
+a 11-tuple where the entries in the tuple are counts of:\n\
+0. all function calls\n\
+1. calls to PyFunction_Type objects\n\
+2. PyFunction calls that do not create an argument tuple\n\
+3. PyFunction calls that do not create an argument tuple\n\
+   and bypass PyEval_EvalCodeEx()\n\
+4. PyMethod calls\n\
+5. PyMethod calls on bound methods\n\
+6. PyType calls\n\
+7. PyCFunction calls\n\
+8. generator calls\n\
+9. All other calls\n\
+10. Number of stack pops performed by call_function()"
+);
+
+static PyObject *
+sys_callstats(PyObject *self)
+{
+    if (PyErr_WarnEx(PyExc_DeprecationWarning,
+                      "sys.callstats() has been deprecated in Python 3.7 "
+                      "and will be removed in the future", 1) < 0) {
+        return NULL;
+    }
+
+    Py_RETURN_NONE;
+}
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+static PyObject *
+sys_debugmallocstats(PyObject *self, PyObject *args)
+{
+#ifdef WITH_PYMALLOC
+    if (_PyObject_DebugMallocStats(stderr)) {
+        fputc('\n', stderr);
+    }
+#endif
+    _PyObject_DebugTypeStats(stderr);
+
+    Py_RETURN_NONE;
+}
+PyDoc_STRVAR(debugmallocstats_doc,
+"_debugmallocstats()\n\
+\n\
+Print summary info to stderr about the state of\n\
+pymalloc's structures.\n\
+\n\
+In Py_DEBUG mode, also perform some expensive internal consistency\n\
+checks.\n\
+");
+
+#ifdef Py_TRACE_REFS
+/* Defined in objects.c because it uses static globals if that file */
+extern PyObject *_Py_GetObjects(PyObject *, PyObject *);
+#endif
+
+#ifdef DYNAMIC_EXECUTION_PROFILE
+/* Defined in ceval.c because it uses static globals if that file */
+extern PyObject *_Py_GetDXProfile(PyObject *,  PyObject *);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+static PyObject *
+sys_clear_type_cache(PyObject* self, PyObject* args)
+{
+    PyType_ClearCache();
+    Py_RETURN_NONE;
+}
+
+PyDoc_STRVAR(sys_clear_type_cache__doc__,
+"_clear_type_cache() -> None\n\
+Clear the internal type lookup cache.");
+
+static PyObject *
+sys_is_finalizing(PyObject* self, PyObject* args)
+{
+    return PyBool_FromLong(_Py_IsFinalizing());
+}
+
+PyDoc_STRVAR(is_finalizing_doc,
+"is_finalizing()\n\
+Return True if Python is exiting.");
+
+
+#ifdef ANDROID_API_LEVEL
+PyDoc_STRVAR(getandroidapilevel_doc,
+"getandroidapilevel()\n\
+\n\
+Return the build time API version of Android as an integer.");
+
+static PyObject *
+sys_getandroidapilevel(PyObject *self)
+{
+    return PyLong_FromLong(ANDROID_API_LEVEL);
+}
+#endif   /* ANDROID_API_LEVEL */
+
+
+static PyMethodDef sys_methods[] = {
+    /* Might as well keep this in alphabetic order */
+    {"breakpointhook",  (PyCFunction)sys_breakpointhook,
+     METH_FASTCALL | METH_KEYWORDS, breakpointhook_doc},
+    {"callstats", (PyCFunction)sys_callstats, METH_NOARGS,
+     callstats_doc},
+    {"_clear_type_cache",       sys_clear_type_cache,     METH_NOARGS,
+     sys_clear_type_cache__doc__},
+    {"_current_frames", sys_current_frames, METH_NOARGS,
+     current_frames_doc},
+    {"displayhook",     sys_displayhook, METH_O, displayhook_doc},
+    {"exc_info",        sys_exc_info, METH_NOARGS, exc_info_doc},
+    {"excepthook",      sys_excepthook, METH_VARARGS, excepthook_doc},
+    {"exit",            sys_exit, METH_VARARGS, exit_doc},
+    {"getdefaultencoding", (PyCFunction)sys_getdefaultencoding,
+     METH_NOARGS, getdefaultencoding_doc},
+#ifdef HAVE_DLOPEN
+    {"getdlopenflags", (PyCFunction)sys_getdlopenflags, METH_NOARGS,
+     getdlopenflags_doc},
+#endif
+    {"getallocatedblocks", (PyCFunction)sys_getallocatedblocks, METH_NOARGS,
+      getallocatedblocks_doc},
+#ifdef COUNT_ALLOCS
+    {"getcounts",       (PyCFunction)sys_getcounts, METH_NOARGS},
+#endif
+#ifdef DYNAMIC_EXECUTION_PROFILE
+    {"getdxp",          _Py_GetDXProfile, METH_VARARGS},
+#endif
+    {"getfilesystemencoding", (PyCFunction)sys_getfilesystemencoding,
+     METH_NOARGS, getfilesystemencoding_doc},
+    { "getfilesystemencodeerrors", (PyCFunction)sys_getfilesystemencodeerrors,
+     METH_NOARGS, getfilesystemencodeerrors_doc },
+#ifdef Py_TRACE_REFS
+    {"getobjects",      _Py_GetObjects, METH_VARARGS},
+#endif
+#ifdef Py_REF_DEBUG
+    {"gettotalrefcount", (PyCFunction)sys_gettotalrefcount, METH_NOARGS},
+#endif
+    {"getrefcount",     (PyCFunction)sys_getrefcount, METH_O, getrefcount_doc},
+    {"getrecursionlimit", (PyCFunction)sys_getrecursionlimit, METH_NOARGS,
+     getrecursionlimit_doc},
+    {"getsizeof",   (PyCFunction)sys_getsizeof,
+     METH_VARARGS | METH_KEYWORDS, getsizeof_doc},
+    {"_getframe", sys_getframe, METH_VARARGS, getframe_doc},
+#ifdef MS_WINDOWS
+    {"getwindowsversion", (PyCFunction)sys_getwindowsversion, METH_NOARGS,
+     getwindowsversion_doc},
+    {"_enablelegacywindowsfsencoding", (PyCFunction)sys_enablelegacywindowsfsencoding,
+     METH_NOARGS, enablelegacywindowsfsencoding_doc },
+#endif /* MS_WINDOWS */
+    {"intern",          sys_intern,     METH_VARARGS, intern_doc},
+    {"is_finalizing",   sys_is_finalizing, METH_NOARGS, is_finalizing_doc},
+#ifdef USE_MALLOPT
+    {"mdebug",          sys_mdebug, METH_VARARGS},
+#endif
+    {"setcheckinterval",        sys_setcheckinterval, METH_VARARGS,
+     setcheckinterval_doc},
+    {"getcheckinterval",        sys_getcheckinterval, METH_NOARGS,
+     getcheckinterval_doc},
+    {"setswitchinterval",       sys_setswitchinterval, METH_VARARGS,
+     setswitchinterval_doc},
+    {"getswitchinterval",       sys_getswitchinterval, METH_NOARGS,
+     getswitchinterval_doc},
+#ifdef HAVE_DLOPEN
+    {"setdlopenflags", sys_setdlopenflags, METH_VARARGS,
+     setdlopenflags_doc},
+#endif
+    {"setprofile",      sys_setprofile, METH_O, setprofile_doc},
+    {"getprofile",      sys_getprofile, METH_NOARGS, getprofile_doc},
+    {"setrecursionlimit", sys_setrecursionlimit, METH_VARARGS,
+     setrecursionlimit_doc},
+    {"settrace",        sys_settrace, METH_O, settrace_doc},
+    {"gettrace",        sys_gettrace, METH_NOARGS, gettrace_doc},
+    {"call_tracing", sys_call_tracing, METH_VARARGS, call_tracing_doc},
+    {"_debugmallocstats", sys_debugmallocstats, METH_NOARGS,
+     debugmallocstats_doc},
+    SYS_SET_COROUTINE_ORIGIN_TRACKING_DEPTH_METHODDEF
+    SYS_GET_COROUTINE_ORIGIN_TRACKING_DEPTH_METHODDEF
+    {"set_coroutine_wrapper", sys_set_coroutine_wrapper, METH_O,
+     set_coroutine_wrapper_doc},
+    {"get_coroutine_wrapper", sys_get_coroutine_wrapper, METH_NOARGS,
+     get_coroutine_wrapper_doc},
+    {"set_asyncgen_hooks", (PyCFunction)sys_set_asyncgen_hooks,
+     METH_VARARGS | METH_KEYWORDS, set_asyncgen_hooks_doc},
+    {"get_asyncgen_hooks", sys_get_asyncgen_hooks, METH_NOARGS,
+     get_asyncgen_hooks_doc},
+#ifdef ANDROID_API_LEVEL
+    {"getandroidapilevel", (PyCFunction)sys_getandroidapilevel, METH_NOARGS,
+     getandroidapilevel_doc},
+#endif
+    {NULL,              NULL}           /* sentinel */
+};
+
+static PyObject *
+list_builtin_module_names(void)
+{
+    PyObject *list = PyList_New(0);
+    int i;
+    if (list == NULL)
+        return NULL;
+    for (i = 0; PyImport_Inittab[i].name != NULL; i++) {
+        PyObject *name = PyUnicode_FromString(
+            PyImport_Inittab[i].name);
+        if (name == NULL)
+            break;
+        PyList_Append(list, name);
+        Py_DECREF(name);
+    }
+    if (PyList_Sort(list) != 0) {
+        Py_DECREF(list);
+        list = NULL;
+    }
+    if (list) {
+        PyObject *v = PyList_AsTuple(list);
+        Py_DECREF(list);
+        list = v;
+    }
+    return list;
+}
+
+/* Pre-initialization support for sys.warnoptions and sys._xoptions
+ *
+ * Modern internal code paths:
+ *   These APIs get called after _Py_InitializeCore and get to use the
+ *   regular CPython list, dict, and unicode APIs.
+ *
+ * Legacy embedding code paths:
+ *   The multi-phase initialization API isn't public yet, so embedding
+ *   apps still need to be able configure sys.warnoptions and sys._xoptions
+ *   before they call Py_Initialize. To support this, we stash copies of
+ *   the supplied wchar * sequences in linked lists, and then migrate the
+ *   contents of those lists to the sys module in _PyInitializeCore.
+ *
+ */
+
+struct _preinit_entry {
+    wchar_t *value;
+    struct _preinit_entry *next;
+};
+
+typedef struct _preinit_entry *_Py_PreInitEntry;
+
+static _Py_PreInitEntry _preinit_warnoptions = NULL;
+static _Py_PreInitEntry _preinit_xoptions = NULL;
+
+static _Py_PreInitEntry
+_alloc_preinit_entry(const wchar_t *value)
+{
+    /* To get this to work, we have to initialize the runtime implicitly */
+    _PyRuntime_Initialize();
+
+    /* Force default allocator, so we can ensure that it also gets used to
+     * destroy the linked list in _clear_preinit_entries.
+     */
+    PyMemAllocatorEx old_alloc;
+    _PyMem_SetDefaultAllocator(PYMEM_DOMAIN_RAW, &old_alloc);
+
+    _Py_PreInitEntry node = PyMem_RawCalloc(1, sizeof(*node));
+    if (node != NULL) {
+        node->value = _PyMem_RawWcsdup(value);
+        if (node->value == NULL) {
+            PyMem_RawFree(node);
+            node = NULL;
+        };
+    };
+
+    PyMem_SetAllocator(PYMEM_DOMAIN_RAW, &old_alloc);
+    return node;
+};
+
+static int
+_append_preinit_entry(_Py_PreInitEntry *optionlist, const wchar_t *value)
+{
+    _Py_PreInitEntry new_entry = _alloc_preinit_entry(value);
+    if (new_entry == NULL) {
+        return -1;
+    }
+    /* We maintain the linked list in this order so it's easy to play back
+     * the add commands in the same order later on in _Py_InitializeCore
+     */
+    _Py_PreInitEntry last_entry = *optionlist;
+    if (last_entry == NULL) {
+        *optionlist = new_entry;
+    } else {
+        while (last_entry->next != NULL) {
+            last_entry = last_entry->next;
+        }
+        last_entry->next = new_entry;
+    }
+    return 0;
+};
+
+static void
+_clear_preinit_entries(_Py_PreInitEntry *optionlist)
+{
+    _Py_PreInitEntry current = *optionlist;
+    *optionlist = NULL;
+    /* Deallocate the nodes and their contents using the default allocator */
+    PyMemAllocatorEx old_alloc;
+    _PyMem_SetDefaultAllocator(PYMEM_DOMAIN_RAW, &old_alloc);
+    while (current != NULL) {
+        _Py_PreInitEntry next = current->next;
+        PyMem_RawFree(current->value);
+        PyMem_RawFree(current);
+        current = next;
+    }
+    PyMem_SetAllocator(PYMEM_DOMAIN_RAW, &old_alloc);
+};
+
+static void
+_clear_all_preinit_options(void)
+{
+    _clear_preinit_entries(&_preinit_warnoptions);
+    _clear_preinit_entries(&_preinit_xoptions);
+}
+
+static int
+_PySys_ReadPreInitOptions(void)
+{
+    /* Rerun the add commands with the actual sys module available */
+    PyThreadState *tstate = PyThreadState_GET();
+    if (tstate == NULL) {
+        /* Still don't have a thread state, so something is wrong! */
+        return -1;
+    }
+    _Py_PreInitEntry entry = _preinit_warnoptions;
+    while (entry != NULL) {
+        PySys_AddWarnOption(entry->value);
+        entry = entry->next;
+    }
+    entry = _preinit_xoptions;
+    while (entry != NULL) {
+        PySys_AddXOption(entry->value);
+        entry = entry->next;
+    }
+
+    _clear_all_preinit_options();
+    return 0;
+};
+
+static PyObject *
+get_warnoptions(void)
+{
+    PyObject *warnoptions = _PySys_GetObjectId(&PyId_warnoptions);
+    if (warnoptions == NULL || !PyList_Check(warnoptions)) {
+        /* PEP432 TODO: we can reach this if warnoptions is NULL in the main
+        *  interpreter config. When that happens, we need to properly set
+         * the `warnoptions` reference in the main interpreter config as well.
+         *
+         * For Python 3.7, we shouldn't be able to get here due to the
+         * combination of how _PyMainInterpreter_ReadConfig and _PySys_EndInit
+         * work, but we expect 3.8+ to make the _PyMainInterpreter_ReadConfig
+         * call optional for embedding applications, thus making this
+         * reachable again.
+         */
+        warnoptions = PyList_New(0);
+        if (warnoptions == NULL)
+            return NULL;
+        if (_PySys_SetObjectId(&PyId_warnoptions, warnoptions)) {
+            Py_DECREF(warnoptions);
+            return NULL;
+        }
+        Py_DECREF(warnoptions);
+    }
+    return warnoptions;
+}
+
+void
+PySys_ResetWarnOptions(void)
+{
+    PyThreadState *tstate = PyThreadState_GET();
+    if (tstate == NULL) {
+        _clear_preinit_entries(&_preinit_warnoptions);
+        return;
+    }
+
+    PyObject *warnoptions = _PySys_GetObjectId(&PyId_warnoptions);
+    if (warnoptions == NULL || !PyList_Check(warnoptions))
+        return;
+    PyList_SetSlice(warnoptions, 0, PyList_GET_SIZE(warnoptions), NULL);
+}
+
+int
+_PySys_AddWarnOptionWithError(PyObject *option)
+{
+    PyObject *warnoptions = get_warnoptions();
+    if (warnoptions == NULL) {
+        return -1;
+    }
+    if (PyList_Append(warnoptions, option)) {
+        return -1;
+    }
+    return 0;
+}
+
+void
+PySys_AddWarnOptionUnicode(PyObject *option)
+{
+    (void)_PySys_AddWarnOptionWithError(option);
+}
+
+void
+PySys_AddWarnOption(const wchar_t *s)
+{
+    PyThreadState *tstate = PyThreadState_GET();
+    if (tstate == NULL) {
+        _append_preinit_entry(&_preinit_warnoptions, s);
+        return;
+    }
+    PyObject *unicode;
+    unicode = PyUnicode_FromWideChar(s, -1);
+    if (unicode == NULL)
+        return;
+    PySys_AddWarnOptionUnicode(unicode);
+    Py_DECREF(unicode);
+}
+
+int
+PySys_HasWarnOptions(void)
+{
+    PyObject *warnoptions = _PySys_GetObjectId(&PyId_warnoptions);
+    return (warnoptions != NULL && PyList_Check(warnoptions)
+            && PyList_GET_SIZE(warnoptions) > 0);
+}
+
+static PyObject *
+get_xoptions(void)
+{
+    PyObject *xoptions = _PySys_GetObjectId(&PyId__xoptions);
+    if (xoptions == NULL || !PyDict_Check(xoptions)) {
+        /* PEP432 TODO: we can reach this if xoptions is NULL in the main
+        *  interpreter config. When that happens, we need to properly set
+         * the `xoptions` reference in the main interpreter config as well.
+         *
+         * For Python 3.7, we shouldn't be able to get here due to the
+         * combination of how _PyMainInterpreter_ReadConfig and _PySys_EndInit
+         * work, but we expect 3.8+ to make the _PyMainInterpreter_ReadConfig
+         * call optional for embedding applications, thus making this
+         * reachable again.
+         */
+        xoptions = PyDict_New();
+        if (xoptions == NULL)
+            return NULL;
+        if (_PySys_SetObjectId(&PyId__xoptions, xoptions)) {
+            Py_DECREF(xoptions);
+            return NULL;
+        }
+        Py_DECREF(xoptions);
+    }
+    return xoptions;
+}
+
+int
+_PySys_AddXOptionWithError(const wchar_t *s)
+{
+    PyObject *name = NULL, *value = NULL;
+
+    PyObject *opts = get_xoptions();
+    if (opts == NULL) {
+        goto error;
+    }
+
+    const wchar_t *name_end = wcschr(s, L'=');
+    if (!name_end) {
+        name = PyUnicode_FromWideChar(s, -1);
+        value = Py_True;
+        Py_INCREF(value);
+    }
+    else {
+        name = PyUnicode_FromWideChar(s, name_end - s);
+        value = PyUnicode_FromWideChar(name_end + 1, -1);
+    }
+    if (name == NULL || value == NULL) {
+        goto error;
+    }
+    if (PyDict_SetItem(opts, name, value) < 0) {
+        goto error;
+    }
+    Py_DECREF(name);
+    Py_DECREF(value);
+    return 0;
+
+error:
+    Py_XDECREF(name);
+    Py_XDECREF(value);
+    return -1;
+}
+
+void
+PySys_AddXOption(const wchar_t *s)
+{
+    PyThreadState *tstate = PyThreadState_GET();
+    if (tstate == NULL) {
+        _append_preinit_entry(&_preinit_xoptions, s);
+        return;
+    }
+    if (_PySys_AddXOptionWithError(s) < 0) {
+        /* No return value, therefore clear error state if possible */
+        if (_PyThreadState_UncheckedGet()) {
+            PyErr_Clear();
+        }
+    }
+}
+
+PyObject *
+PySys_GetXOptions(void)
+{
+    return get_xoptions();
+}
+
+/* XXX This doc string is too long to be a single string literal in VC++ 5.0.
+   Two literals concatenated works just fine.  If you have a K&R compiler
+   or other abomination that however *does* understand longer strings,
+   get rid of the !!! comment in the middle and the quotes that surround it. */
+PyDoc_VAR(sys_doc) =
+PyDoc_STR(
+"This module provides access to some objects used or maintained by the\n\
+interpreter and to functions that interact strongly with the interpreter.\n\
+\n\
+Dynamic objects:\n\
+\n\
+argv -- command line arguments; argv[0] is the script pathname if known\n\
+path -- module search path; path[0] is the script directory, else ''\n\
+modules -- dictionary of loaded modules\n\
+\n\
+displayhook -- called to show results in an interactive session\n\
+excepthook -- called to handle any uncaught exception other than SystemExit\n\
+  To customize printing in an interactive session or to install a custom\n\
+  top-level exception handler, assign other functions to replace these.\n\
+\n\
+stdin -- standard input file object; used by input()\n\
+stdout -- standard output file object; used by print()\n\
+stderr -- standard error object; used for error messages\n\
+  By assigning other file objects (or objects that behave like files)\n\
+  to these, it is possible to redirect all of the interpreter's I/O.\n\
+\n\
+last_type -- type of last uncaught exception\n\
+last_value -- value of last uncaught exception\n\
+last_traceback -- traceback of last uncaught exception\n\
+  These three are only available in an interactive session after a\n\
+  traceback has been printed.\n\
+"
+)
+/* concatenating string here */
+PyDoc_STR(
+"\n\
+Static objects:\n\
+\n\
+builtin_module_names -- tuple of module names built into this interpreter\n\
+copyright -- copyright notice pertaining to this interpreter\n\
+exec_prefix -- prefix used to find the machine-specific Python library\n\
+executable -- absolute path of the executable binary of the Python interpreter\n\
+float_info -- a struct sequence with information about the float implementation.\n\
+float_repr_style -- string indicating the style of repr() output for floats\n\
+hash_info -- a struct sequence with information about the hash algorithm.\n\
+hexversion -- version information encoded as a single integer\n\
+implementation -- Python implementation information.\n\
+int_info -- a struct sequence with information about the int implementation.\n\
+maxsize -- the largest supported length of containers.\n\
+maxunicode -- the value of the largest Unicode code point\n\
+platform -- platform identifier\n\
+prefix -- prefix used to find the Python library\n\
+thread_info -- a struct sequence with information about the thread implementation.\n\
+version -- the version of this interpreter as a string\n\
+version_info -- version information as a named tuple\n\
+"
+)
+#ifdef MS_COREDLL
+/* concatenating string here */
+PyDoc_STR(
+"dllhandle -- [Windows only] integer handle of the Python DLL\n\
+winver -- [Windows only] version number of the Python DLL\n\
+"
+)
+#endif /* MS_COREDLL */
+#ifdef MS_WINDOWS
+/* concatenating string here */
+PyDoc_STR(
+"_enablelegacywindowsfsencoding -- [Windows only] \n\
+"
+)
+#endif
+PyDoc_STR(
+"__stdin__ -- the original stdin; don't touch!\n\
+__stdout__ -- the original stdout; don't touch!\n\
+__stderr__ -- the original stderr; don't touch!\n\
+__displayhook__ -- the original displayhook; don't touch!\n\
+__excepthook__ -- the original excepthook; don't touch!\n\
+\n\
+Functions:\n\
+\n\
+displayhook() -- print an object to the screen, and save it in builtins._\n\
+excepthook() -- print an exception and its traceback to sys.stderr\n\
+exc_info() -- return thread-safe information about the current exception\n\
+exit() -- exit the interpreter by raising SystemExit\n\
+getdlopenflags() -- returns flags to be used for dlopen() calls\n\
+getprofile() -- get the global profiling function\n\
+getrefcount() -- return the reference count for an object (plus one :-)\n\
+getrecursionlimit() -- return the max recursion depth for the interpreter\n\
+getsizeof() -- return the size of an object in bytes\n\
+gettrace() -- get the global debug tracing function\n\
+setcheckinterval() -- control how often the interpreter checks for events\n\
+setdlopenflags() -- set the flags to be used for dlopen() calls\n\
+setprofile() -- set the global profiling function\n\
+setrecursionlimit() -- set the max recursion depth for the interpreter\n\
+settrace() -- set the global debug tracing function\n\
+"
+)
+/* end of sys_doc */ ;
+
+
+PyDoc_STRVAR(flags__doc__,
+"sys.flags\n\
+\n\
+Flags provided through command line arguments or environment vars.");
+
+static PyTypeObject FlagsType;
+
+static PyStructSequence_Field flags_fields[] = {
+    {"debug",                   "-d"},
+    {"inspect",                 "-i"},
+    {"interactive",             "-i"},
+    {"optimize",                "-O or -OO"},
+    {"dont_write_bytecode",     "-B"},
+    {"no_user_site",            "-s"},
+    {"no_site",                 "-S"},
+    {"ignore_environment",      "-E"},
+    {"verbose",                 "-v"},
+    /* {"unbuffered",                   "-u"}, */
+    /* {"skip_first",                   "-x"}, */
+    {"bytes_warning",           "-b"},
+    {"quiet",                   "-q"},
+    {"hash_randomization",      "-R"},
+    {"isolated",                "-I"},
+    {"dev_mode",                "-X dev"},
+    {"utf8_mode",               "-X utf8"},
+    {0}
+};
+
+static PyStructSequence_Desc flags_desc = {
+    "sys.flags",        /* name */
+    flags__doc__,       /* doc */
+    flags_fields,       /* fields */
+    15
+};
+
+static PyObject*
+make_flags(void)
+{
+    int pos = 0;
+    PyObject *seq;
+    _PyCoreConfig *core_config = &_PyGILState_GetInterpreterStateUnsafe()->core_config;
+
+    seq = PyStructSequence_New(&FlagsType);
+    if (seq == NULL)
+        return NULL;
+
+#define SetFlag(flag) \
+    PyStructSequence_SET_ITEM(seq, pos++, PyLong_FromLong(flag))
+
+    SetFlag(Py_DebugFlag);
+    SetFlag(Py_InspectFlag);
+    SetFlag(Py_InteractiveFlag);
+    SetFlag(Py_OptimizeFlag);
+    SetFlag(Py_DontWriteBytecodeFlag);
+    SetFlag(Py_NoUserSiteDirectory);
+    SetFlag(Py_NoSiteFlag);
+    SetFlag(Py_IgnoreEnvironmentFlag);
+    SetFlag(Py_VerboseFlag);
+    /* SetFlag(saw_unbuffered_flag); */
+    /* SetFlag(skipfirstline); */
+    SetFlag(Py_BytesWarningFlag);
+    SetFlag(Py_QuietFlag);
+    SetFlag(Py_HashRandomizationFlag);
+    SetFlag(Py_IsolatedFlag);
+    PyStructSequence_SET_ITEM(seq, pos++, PyBool_FromLong(core_config->dev_mode));
+    SetFlag(Py_UTF8Mode);
+#undef SetFlag
+
+    if (PyErr_Occurred()) {
+        Py_DECREF(seq);
+        return NULL;
+    }
+    return seq;
+}
+
+PyDoc_STRVAR(version_info__doc__,
+"sys.version_info\n\
+\n\
+Version information as a named tuple.");
+
+static PyTypeObject VersionInfoType;
+
+static PyStructSequence_Field version_info_fields[] = {
+    {"major", "Major release number"},
+    {"minor", "Minor release number"},
+    {"micro", "Patch release number"},
+    {"releaselevel", "'alpha', 'beta', 'candidate', or 'final'"},
+    {"serial", "Serial release number"},
+    {0}
+};
+
+static PyStructSequence_Desc version_info_desc = {
+    "sys.version_info",     /* name */
+    version_info__doc__,    /* doc */
+    version_info_fields,    /* fields */
+    5
+};
+
+static PyObject *
+make_version_info(void)
+{
+    PyObject *version_info;
+    char *s;
+    int pos = 0;
+
+    version_info = PyStructSequence_New(&VersionInfoType);
+    if (version_info == NULL) {
+        return NULL;
+    }
+
+    /*
+     * These release level checks are mutually exclusive and cover
+     * the field, so don't get too fancy with the pre-processor!
+     */
+#if PY_RELEASE_LEVEL == PY_RELEASE_LEVEL_ALPHA
+    s = "alpha";
+#elif PY_RELEASE_LEVEL == PY_RELEASE_LEVEL_BETA
+    s = "beta";
+#elif PY_RELEASE_LEVEL == PY_RELEASE_LEVEL_GAMMA
+    s = "candidate";
+#elif PY_RELEASE_LEVEL == PY_RELEASE_LEVEL_FINAL
+    s = "final";
+#endif
+
+#define SetIntItem(flag) \
+    PyStructSequence_SET_ITEM(version_info, pos++, PyLong_FromLong(flag))
+#define SetStrItem(flag) \
+    PyStructSequence_SET_ITEM(version_info, pos++, PyUnicode_FromString(flag))
+
+    SetIntItem(PY_MAJOR_VERSION);
+    SetIntItem(PY_MINOR_VERSION);
+    SetIntItem(PY_MICRO_VERSION);
+    SetStrItem(s);
+    SetIntItem(PY_RELEASE_SERIAL);
+#undef SetIntItem
+#undef SetStrItem
+
+    if (PyErr_Occurred()) {
+        Py_CLEAR(version_info);
+        return NULL;
+    }
+    return version_info;
+}
+
+/* sys.implementation values */
+#define NAME "cpython"
+const char *_PySys_ImplName = NAME;
+#define MAJOR Py_STRINGIFY(PY_MAJOR_VERSION)
+#define MINOR Py_STRINGIFY(PY_MINOR_VERSION)
+#define TAG NAME "-" MAJOR MINOR
+const char *_PySys_ImplCacheTag = TAG;
+#undef NAME
+#undef MAJOR
+#undef MINOR
+#undef TAG
+
+static PyObject *
+make_impl_info(PyObject *version_info)
+{
+    int res;
+    PyObject *impl_info, *value, *ns;
+
+    impl_info = PyDict_New();
+    if (impl_info == NULL)
+        return NULL;
+
+    /* populate the dict */
+
+    value = PyUnicode_FromString(_PySys_ImplName);
+    if (value == NULL)
+        goto error;
+    res = PyDict_SetItemString(impl_info, "name", value);
+    Py_DECREF(value);
+    if (res < 0)
+        goto error;
+
+    value = PyUnicode_FromString(_PySys_ImplCacheTag);
+    if (value == NULL)
+        goto error;
+    res = PyDict_SetItemString(impl_info, "cache_tag", value);
+    Py_DECREF(value);
+    if (res < 0)
+        goto error;
+
+    res = PyDict_SetItemString(impl_info, "version", version_info);
+    if (res < 0)
+        goto error;
+
+    value = PyLong_FromLong(PY_VERSION_HEX);
+    if (value == NULL)
+        goto error;
+    res = PyDict_SetItemString(impl_info, "hexversion", value);
+    Py_DECREF(value);
+    if (res < 0)
+        goto error;
+
+#ifdef MULTIARCH
+    value = PyUnicode_FromString(MULTIARCH);
+    if (value == NULL)
+        goto error;
+    res = PyDict_SetItemString(impl_info, "_multiarch", value);
+    Py_DECREF(value);
+    if (res < 0)
+        goto error;
+#endif
+
+    /* dict ready */
+
+    ns = _PyNamespace_New(impl_info);
+    Py_DECREF(impl_info);
+    return ns;
+
+error:
+    Py_CLEAR(impl_info);
+    return NULL;
+}
+
+static struct PyModuleDef sysmodule = {
+    PyModuleDef_HEAD_INIT,
+    "sys",
+    sys_doc,
+    -1, /* multiple "initialization" just copies the module dict. */
+    sys_methods,
+    NULL,
+    NULL,
+    NULL,
+    NULL
+};
+
+/* Updating the sys namespace, returning NULL pointer on error */
+#define SET_SYS_FROM_STRING_BORROW(key, value)             \
+    do {                                                   \
+        PyObject *v = (value);                             \
+        if (v == NULL) {                                   \
+            goto err_occurred;                             \
+        }                                                  \
+        res = PyDict_SetItemString(sysdict, key, v);       \
+        if (res < 0) {                                     \
+            goto err_occurred;                             \
+        }                                                  \
+    } while (0)
+#define SET_SYS_FROM_STRING(key, value)                    \
+    do {                                                   \
+        PyObject *v = (value);                             \
+        if (v == NULL) {                                   \
+            goto err_occurred;                             \
+        }                                                  \
+        res = PyDict_SetItemString(sysdict, key, v);       \
+        Py_DECREF(v);                                      \
+        if (res < 0) {                                     \
+            goto err_occurred;                             \
+        }                                                  \
+    } while (0)
+
+
+_PyInitError
+_PySys_BeginInit(PyObject **sysmod)
+{
+    PyObject *m, *sysdict, *version_info;
+    int res;
+
+    m = _PyModule_CreateInitialized(&sysmodule, PYTHON_API_VERSION);
+    if (m == NULL) {
+        return _Py_INIT_ERR("failed to create a module object");
+    }
+    sysdict = PyModule_GetDict(m);
+
+    /* Check that stdin is not a directory
+       Using shell redirection, you can redirect stdin to a directory,
+       crashing the Python interpreter. Catch this common mistake here
+       and output a useful error message. Note that under MS Windows,
+       the shell already prevents that. */
+#ifndef MS_WINDOWS
+    {
+        struct _Py_stat_struct sb;
+        if (_Py_fstat_noraise(fileno(stdin), &sb) == 0 &&
+            S_ISDIR(sb.st_mode)) {
+            return _Py_INIT_USER_ERR("<stdin> is a directory, "
+                                     "cannot continue");
+        }
+    }
+#endif
+
+    /* stdin/stdout/stderr are set in pylifecycle.c */
+
+    SET_SYS_FROM_STRING_BORROW("__displayhook__",
+                               PyDict_GetItemString(sysdict, "displayhook"));
+    SET_SYS_FROM_STRING_BORROW("__excepthook__",
+                               PyDict_GetItemString(sysdict, "excepthook"));
+    SET_SYS_FROM_STRING_BORROW(
+        "__breakpointhook__",
+        PyDict_GetItemString(sysdict, "breakpointhook"));
+    SET_SYS_FROM_STRING("version",
+                         PyUnicode_FromString(Py_GetVersion()));
+    SET_SYS_FROM_STRING("hexversion",
+                         PyLong_FromLong(PY_VERSION_HEX));
+    SET_SYS_FROM_STRING("_git",
+                        Py_BuildValue("(szz)", "CPython", _Py_gitidentifier(),
+                                      _Py_gitversion()));
+    SET_SYS_FROM_STRING("_framework", PyUnicode_FromString(_PYTHONFRAMEWORK));
+    SET_SYS_FROM_STRING("api_version",
+                        PyLong_FromLong(PYTHON_API_VERSION));
+    SET_SYS_FROM_STRING("copyright",
+                        PyUnicode_FromString(Py_GetCopyright()));
+    SET_SYS_FROM_STRING("platform",
+                        PyUnicode_FromString(Py_GetPlatform()));
+    SET_SYS_FROM_STRING("maxsize",
+                        PyLong_FromSsize_t(PY_SSIZE_T_MAX));
+    SET_SYS_FROM_STRING("float_info",
+                        PyFloat_GetInfo());
+    SET_SYS_FROM_STRING("int_info",
+                        PyLong_GetInfo());
+    /* initialize hash_info */
+    if (Hash_InfoType.tp_name == NULL) {
+        if (PyStructSequence_InitType2(&Hash_InfoType, &hash_info_desc) < 0) {
+            goto type_init_failed;
+        }
+    }
+    SET_SYS_FROM_STRING("hash_info",
+                        get_hash_info());
+    SET_SYS_FROM_STRING("maxunicode",
+                        PyLong_FromLong(0x10FFFF));
+    SET_SYS_FROM_STRING("builtin_module_names",
+                        list_builtin_module_names());
+#if PY_BIG_ENDIAN
+    SET_SYS_FROM_STRING("byteorder",
+                        PyUnicode_FromString("big"));
+#else
+    SET_SYS_FROM_STRING("byteorder",
+                        PyUnicode_FromString("little"));
+#endif
+
+#ifdef MS_COREDLL
+    SET_SYS_FROM_STRING("dllhandle",
+                        PyLong_FromVoidPtr(PyWin_DLLhModule));
+    SET_SYS_FROM_STRING("winver",
+                        PyUnicode_FromString(PyWin_DLLVersionString));
+#endif
+#ifdef ABIFLAGS
+    SET_SYS_FROM_STRING("abiflags",
+                        PyUnicode_FromString(ABIFLAGS));
+#endif
+
+    /* version_info */
+    if (VersionInfoType.tp_name == NULL) {
+        if (PyStructSequence_InitType2(&VersionInfoType,
+                                       &version_info_desc) < 0) {
+            goto type_init_failed;
+        }
+    }
+    version_info = make_version_info();
+    SET_SYS_FROM_STRING("version_info", version_info);
+    /* prevent user from creating new instances */
+    VersionInfoType.tp_init = NULL;
+    VersionInfoType.tp_new = NULL;
+    res = PyDict_DelItemString(VersionInfoType.tp_dict, "__new__");
+    if (res < 0 && PyErr_ExceptionMatches(PyExc_KeyError))
+        PyErr_Clear();
+
+    /* implementation */
+    SET_SYS_FROM_STRING("implementation", make_impl_info(version_info));
+
+    /* flags */
+    if (FlagsType.tp_name == 0) {
+        if (PyStructSequence_InitType2(&FlagsType, &flags_desc) < 0) {
+            goto type_init_failed;
+        }
+    }
+    /* Set flags to their default values */
+    SET_SYS_FROM_STRING("flags", make_flags());
+
+#if defined(MS_WINDOWS)
+    /* getwindowsversion */
+    if (WindowsVersionType.tp_name == 0)
+        if (PyStructSequence_InitType2(&WindowsVersionType,
+                                       &windows_version_desc) < 0) {
+            goto type_init_failed;
+        }
+    /* prevent user from creating new instances */
+    WindowsVersionType.tp_init = NULL;
+    WindowsVersionType.tp_new = NULL;
+    assert(!PyErr_Occurred());
+    res = PyDict_DelItemString(WindowsVersionType.tp_dict, "__new__");
+    if (res < 0 && PyErr_ExceptionMatches(PyExc_KeyError)) {
+        PyErr_Clear();
+    }
+#endif
+
+    /* float repr style: 0.03 (short) vs 0.029999999999999999 (legacy) */
+#ifndef PY_NO_SHORT_FLOAT_REPR
+    SET_SYS_FROM_STRING("float_repr_style",
+                        PyUnicode_FromString("short"));
+#else
+    SET_SYS_FROM_STRING("float_repr_style",
+                        PyUnicode_FromString("legacy"));
+#endif
+
+    SET_SYS_FROM_STRING("thread_info", PyThread_GetInfo());
+
+    /* initialize asyncgen_hooks */
+    if (AsyncGenHooksType.tp_name == NULL) {
+        if (PyStructSequence_InitType2(
+                &AsyncGenHooksType, &asyncgen_hooks_desc) < 0) {
+            goto type_init_failed;
+        }
+    }
+
+    if (PyErr_Occurred()) {
+        goto err_occurred;
+    }
+
+    *sysmod = m;
+
+    return _Py_INIT_OK();
+
+type_init_failed:
+    return _Py_INIT_ERR("failed to initialize a type");
+
+err_occurred:
+    return _Py_INIT_ERR("can't initialize sys module");
+}
+
+#undef SET_SYS_FROM_STRING
+
+/* Updating the sys namespace, returning integer error codes */
+#define SET_SYS_FROM_STRING_INT_RESULT(key, value)         \
+    do {                                                   \
+        PyObject *v = (value);                             \
+        if (v == NULL)                                     \
+            return -1;                                     \
+        res = PyDict_SetItemString(sysdict, key, v);       \
+        Py_DECREF(v);                                      \
+        if (res < 0) {                                     \
+            return res;                                    \
+        }                                                  \
+    } while (0)
+
+int
+_PySys_EndInit(PyObject *sysdict, _PyMainInterpreterConfig *config)
+{
+    int res;
+
+    /* _PyMainInterpreterConfig_Read() must set all these variables */
+    assert(config->module_search_path != NULL);
+    assert(config->executable != NULL);
+    assert(config->prefix != NULL);
+    assert(config->base_prefix != NULL);
+    assert(config->exec_prefix != NULL);
+    assert(config->base_exec_prefix != NULL);
+
+    SET_SYS_FROM_STRING_BORROW("path", config->module_search_path);
+    SET_SYS_FROM_STRING_BORROW("executable", config->executable);
+    SET_SYS_FROM_STRING_BORROW("prefix", config->prefix);
+    SET_SYS_FROM_STRING_BORROW("base_prefix", config->base_prefix);
+    SET_SYS_FROM_STRING_BORROW("exec_prefix", config->exec_prefix);
+    SET_SYS_FROM_STRING_BORROW("base_exec_prefix", config->base_exec_prefix);
+
+    if (config->argv != NULL) {
+        SET_SYS_FROM_STRING_BORROW("argv", config->argv);
+    }
+    if (config->warnoptions != NULL) {
+        SET_SYS_FROM_STRING_BORROW("warnoptions", config->warnoptions);
+    }
+    if (config->xoptions != NULL) {
+        SET_SYS_FROM_STRING_BORROW("_xoptions", config->xoptions);
+    }
+
+    /* Set flags to their final values */
+    SET_SYS_FROM_STRING_INT_RESULT("flags", make_flags());
+    /* prevent user from creating new instances */
+    FlagsType.tp_init = NULL;
+    FlagsType.tp_new = NULL;
+    res = PyDict_DelItemString(FlagsType.tp_dict, "__new__");
+    if (res < 0) {
+        if (!PyErr_ExceptionMatches(PyExc_KeyError)) {
+            return res;
+        }
+        PyErr_Clear();
+    }
+
+    SET_SYS_FROM_STRING_INT_RESULT("dont_write_bytecode",
+                         PyBool_FromLong(Py_DontWriteBytecodeFlag));
+
+    if (get_warnoptions() == NULL)
+        return -1;
+
+    if (get_xoptions() == NULL)
+        return -1;
+
+    /* Transfer any sys.warnoptions and sys._xoptions set directly
+     * by an embedding application from the linked list to the module. */
+    if (_PySys_ReadPreInitOptions() != 0)
+        return -1;
+
+    if (PyErr_Occurred())
+        return -1;
+    return 0;
+
+err_occurred:
+    return -1;
+}
+
+#undef SET_SYS_FROM_STRING_BORROW
+#undef SET_SYS_FROM_STRING_INT_RESULT
+
+static PyObject *
+makepathobject(const wchar_t *path, wchar_t delim)
+{
+    int i, n;
+    const wchar_t *p;
+    PyObject *v, *w;
+
+    n = 1;
+    p = path;
+    while ((p = wcschr(p, delim)) != NULL) {
+        n++;
+        p++;
+    }
+    v = PyList_New(n);
+    if (v == NULL)
+        return NULL;
+    for (i = 0; ; i++) {
+        p = wcschr(path, delim);
+        if (p == NULL)
+            p = path + wcslen(path); /* End of string */
+        w = PyUnicode_FromWideChar(path, (Py_ssize_t)(p - path));
+        if (w == NULL) {
+            Py_DECREF(v);
+            return NULL;
+        }
+        PyList_SET_ITEM(v, i, w);
+        if (*p == '\0')
+            break;
+        path = p+1;
+    }
+    return v;
+}
+
+void
+PySys_SetPath(const wchar_t *path)
+{
+    PyObject *v;
+    if ((v = makepathobject(path, DELIM)) == NULL)
+        Py_FatalError("can't create sys.path");
+    if (_PySys_SetObjectId(&PyId_path, v) != 0)
+        Py_FatalError("can't assign sys.path");
+    Py_DECREF(v);
+}
+
+static PyObject *
+makeargvobject(int argc, wchar_t **argv)
+{
+    PyObject *av;
+    if (argc <= 0 || argv == NULL) {
+        /* Ensure at least one (empty) argument is seen */
+        static wchar_t *empty_argv[1] = {L""};
+        argv = empty_argv;
+        argc = 1;
+    }
+    av = PyList_New(argc);
+    if (av != NULL) {
+        int i;
+        for (i = 0; i < argc; i++) {
+            PyObject *v = PyUnicode_FromWideChar(argv[i], -1);
+            if (v == NULL) {
+                Py_DECREF(av);
+                av = NULL;
+                break;
+            }
+            PyList_SET_ITEM(av, i, v);
+        }
+    }
+    return av;
+}
+
+void
+PySys_SetArgvEx(int argc, wchar_t **argv, int updatepath)
+{
+    PyObject *av = makeargvobject(argc, argv);
+    if (av == NULL) {
+        Py_FatalError("no mem for sys.argv");
+    }
+    if (PySys_SetObject("argv", av) != 0) {
+        Py_DECREF(av);
+        Py_FatalError("can't assign sys.argv");
+    }
+    Py_DECREF(av);
+
+    if (updatepath) {
+        /* If argv[0] is not '-c' nor '-m', prepend argv[0] to sys.path.
+           If argv[0] is a symlink, use the real path. */
+        PyObject *argv0 = _PyPathConfig_ComputeArgv0(argc, argv);
+        if (argv0 == NULL) {
+            Py_FatalError("can't compute path0 from argv");
+        }
+
+        PyObject *sys_path = _PySys_GetObjectId(&PyId_path);
+        if (sys_path != NULL) {
+            if (PyList_Insert(sys_path, 0, argv0) < 0) {
+                Py_DECREF(argv0);
+                Py_FatalError("can't prepend path0 to sys.path");
+            }
+        }
+        Py_DECREF(argv0);
+    }
+}
+
+void
+PySys_SetArgv(int argc, wchar_t **argv)
+{
+    PySys_SetArgvEx(argc, argv, Py_IsolatedFlag == 0);
+}
+
+/* Reimplementation of PyFile_WriteString() no calling indirectly
+   PyErr_CheckSignals(): avoid the call to PyObject_Str(). */
+
+static int
+sys_pyfile_write_unicode(PyObject *unicode, PyObject *file)
+{
+    PyObject *writer = NULL, *result = NULL;
+    int err;
+
+    if (file == NULL)
+        return -1;
+
+    writer = _PyObject_GetAttrId(file, &PyId_write);
+    if (writer == NULL)
+        goto error;
+
+    result = PyObject_CallFunctionObjArgs(writer, unicode, NULL);
+    if (result == NULL) {
+        goto error;
+    } else {
+        err = 0;
+        goto finally;
+    }
+
+error:
+    err = -1;
+finally:
+    Py_XDECREF(writer);
+    Py_XDECREF(result);
+    return err;
+}
+
+static int
+sys_pyfile_write(const char *text, PyObject *file)
+{
+    PyObject *unicode = NULL;
+    int err;
+
+    if (file == NULL)
+        return -1;
+
+    unicode = PyUnicode_FromString(text);
+    if (unicode == NULL)
+        return -1;
+
+    err = sys_pyfile_write_unicode(unicode, file);
+    Py_DECREF(unicode);
+    return err;
+}
+
+/* APIs to write to sys.stdout or sys.stderr using a printf-like interface.
+   Adapted from code submitted by Just van Rossum.
+
+   PySys_WriteStdout(format, ...)
+   PySys_WriteStderr(format, ...)
+
+      The first function writes to sys.stdout; the second to sys.stderr.  When
+      there is a problem, they write to the real (C level) stdout or stderr;
+      no exceptions are raised.
+
+      PyErr_CheckSignals() is not called to avoid the execution of the Python
+      signal handlers: they may raise a new exception whereas sys_write()
+      ignores all exceptions.
+
+      Both take a printf-style format string as their first argument followed
+      by a variable length argument list determined by the format string.
+
+      *** WARNING ***
+
+      The format should limit the total size of the formatted output string to
+      1000 bytes.  In particular, this means that no unrestricted "%s" formats
+      should occur; these should be limited using "%.<N>s where <N> is a
+      decimal number calculated so that <N> plus the maximum size of other
+      formatted text does not exceed 1000 bytes.  Also watch out for "%f",
+      which can print hundreds of digits for very large numbers.
+
+ */
+
+static void
+sys_write(_Py_Identifier *key, FILE *fp, const char *format, va_list va)
+{
+    PyObject *file;
+    PyObject *error_type, *error_value, *error_traceback;
+    char buffer[1001];
+    int written;
+
+    PyErr_Fetch(&error_type, &error_value, &error_traceback);
+    file = _PySys_GetObjectId(key);
+    written = PyOS_vsnprintf(buffer, sizeof(buffer), format, va);
+    if (sys_pyfile_write(buffer, file) != 0) {
+        PyErr_Clear();
+        fputs(buffer, fp);
+    }
+    if (written < 0 || (size_t)written >= sizeof(buffer)) {
+        const char *truncated = "... truncated";
+        if (sys_pyfile_write(truncated, file) != 0)
+            fputs(truncated, fp);
+    }
+    PyErr_Restore(error_type, error_value, error_traceback);
+}
+
+void
+PySys_WriteStdout(const char *format, ...)
+{
+    va_list va;
+
+    va_start(va, format);
+    sys_write(&PyId_stdout, stdout, format, va);
+    va_end(va);
+}
+
+void
+PySys_WriteStderr(const char *format, ...)
+{
+    va_list va;
+
+    va_start(va, format);
+    sys_write(&PyId_stderr, stderr, format, va);
+    va_end(va);
+}
+
+static void
+sys_format(_Py_Identifier *key, FILE *fp, const char *format, va_list va)
+{
+    PyObject *file, *message;
+    PyObject *error_type, *error_value, *error_traceback;
+    const char *utf8;
+
+    PyErr_Fetch(&error_type, &error_value, &error_traceback);
+    file = _PySys_GetObjectId(key);
+    message = PyUnicode_FromFormatV(format, va);
+    if (message != NULL) {
+        if (sys_pyfile_write_unicode(message, file) != 0) {
+            PyErr_Clear();
+            utf8 = PyUnicode_AsUTF8(message);
+            if (utf8 != NULL)
+                fputs(utf8, fp);
+        }
+        Py_DECREF(message);
+    }
+    PyErr_Restore(error_type, error_value, error_traceback);
+}
+
+void
+PySys_FormatStdout(const char *format, ...)
+{
+    va_list va;
+
+    va_start(va, format);
+    sys_format(&PyId_stdout, stdout, format, va);
+    va_end(va);
+}
+
+void
+PySys_FormatStderr(const char *format, ...)
+{
+    va_list va;
+
+    va_start(va, format);
+    sys_format(&PyId_stderr, stderr, format, va);
+    va_end(va);
+}
